-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Counter is
  generic ( Bits: integer ); 
  port (
    p_out: out std_logic_vector((Bits-1) downto 0);
    ovf: out std_logic;
    C: in std_logic;
    en: in std_logic;
    clr: in std_logic );
end DIG_Counter;

architecture Behavioral of DIG_Counter is
   signal count : std_logic_vector((Bits-1) downto 0) := (others => '0');
begin
    process (C, clr, en)
    begin
      if rising_edge(C) then
        if clr='1' then
          count <= (others => '0');
        elsif en='1' then
          count <= count + 1;
        end if;
      end if;
    end process;

    p_out <= count;
    ovf <= en when count = ((2**Bits)-1) else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register_BUS is
  generic ( Bits: integer ); 
  port (
    Q: out std_logic_vector ((Bits-1) downto 0);
    D: in std_logic_vector ((Bits-1) downto 0);
    C: in std_logic;
    en: in std_logic );
end DIG_Register_BUS;

architecture Behavioral of DIG_Register_BUS is
  signal state : std_logic_vector ((Bits-1) downto 0) := (others => '0');
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity singExtend is
  port (
    inst: in std_logic_vector(15 downto 0); -- instruction word
    n4S: out std_logic_vector(15 downto 0); -- The four bits taken from Rs.
    n8SD: out std_logic_vector(15 downto 0); -- The eight bits taken from Rs,Rd with sign extension.
    n4D: out std_logic_vector(15 downto 0) -- The four bits taken from Rd.
    );
end singExtend;

architecture Behavioral of singExtend is
  signal s0: std_logic;
begin
  n4D(3 downto 0) <= inst(7 downto 4);
  n4D(15 downto 4) <= "000000000000";
  n4S(3 downto 0) <= inst(3 downto 0);
  n4S(15 downto 4) <= "000000000000";
  s0 <= inst(7);
  n8SD(6 downto 0) <= inst(6 downto 0);
  n8SD(7) <= s0;
  n8SD(8) <= s0;
  n8SD(9) <= s0;
  n8SD(10) <= s0;
  n8SD(11) <= s0;
  n8SD(12) <= s0;
  n8SD(13) <= s0;
  n8SD(14) <= s0;
  n8SD(15) <= s0;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_1 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic;
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_1;

architecture Behavioral of MUX_GATE_BUS_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity controllogic is
  port (
    A: in std_logic;
    B: in std_logic;
    C: in std_logic;
    D: in std_logic;
    E: in std_logic;
    F: in std_logic;
    G: in std_logic;
    muxb0: out std_logic;
    muxb1: out std_logic;
    muxb2: out std_logic;
    src2D: out std_logic;
    aluop0: out std_logic;
    aluop1: out std_logic;
    aluop2: out std_logic;
    aluop3: out std_logic;
    aluop4: out std_logic;
    WE: out std_logic;
    sf: out std_logic;
    alu2D: out std_logic;
    iem0: out std_logic;
    iem1: out std_logic;
    br0: out std_logic;
    br1: out std_logic;
    br2: out std_logic;
    muxA: out std_logic;
    ld: out std_logic;
    st: out std_logic;
    p_abs: out std_logic;
    ioW: out std_logic;
    ioR: out std_logic;
    stPC: out std_logic;
    Reti: out std_logic;
    randomSel: out std_logic;
    timerSel: out std_logic);
end controllogic;

architecture Behavioral of controllogic is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
begin
  s6 <= NOT A;
  s0 <= NOT B;
  s1 <= NOT C;
  s2 <= NOT D;
  s3 <= NOT E;
  s5 <= NOT F;
  s4 <= NOT G;
  muxb0 <= ((A AND s0 AND s1 AND s2 AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND E AND F AND G) OR (A AND s0 AND s1 AND D AND s3 AND s5 AND s4) OR (s6 AND s1 AND D AND E AND F AND s4) OR (s6 AND B AND C AND s3 AND s5 AND s4) OR (s6 AND s0 AND s1 AND D AND F AND s4) OR (s6 AND s0 AND s1 AND D AND E AND s4) OR (s6 AND s0 AND C AND s2 AND s3 AND s4) OR (s6 AND B AND s1 AND s2 AND s3 AND G) OR (s6 AND C AND D AND s5 AND G) OR (s6 AND C AND s2 AND E AND G) OR (s6 AND B AND C AND E AND G) OR (s6 AND B AND C AND s2 AND E));
  muxb1 <= ((A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s6 AND C AND s2 AND s3 AND s5 AND G) OR (s6 AND B AND s1 AND s2 AND s3 AND s4) OR (A AND s0 AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s5) OR (s6 AND s1 AND D AND F AND G) OR (s6 AND C AND D AND s5 AND s4) OR (s6 AND B AND C AND s5 AND G) OR (s6 AND B AND C AND F AND s4) OR (s6 AND C AND s2 AND E AND s4) OR (s6 AND s0 AND s1 AND D AND G) OR (s6 AND B AND D AND E) OR (s6 AND B AND C AND E));
  muxb2 <= ((s6 AND B AND C AND D AND E AND F AND G) OR (s6 AND C AND s2 AND s3 AND s5 AND s4) OR (s6 AND B AND s2 AND s3 AND F AND G) OR (s6 AND B AND s1 AND s3 AND F AND G) OR (A AND s0 AND s1 AND s3 AND s5 AND s4) OR (s6 AND s0 AND s1 AND D AND F AND s4) OR (s6 AND s0 AND C AND D AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND F AND G) OR (s6 AND s0 AND C AND s2 AND s3 AND s4) OR (s6 AND s0 AND C AND s2 AND E AND G) OR (s6 AND B AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s4) OR (s6 AND s1 AND D AND E AND s4));
  src2D <= ((s6 AND s0 AND s1 AND s2 AND s3 AND s5 AND G) OR (s6 AND B AND s1 AND D AND s3 AND F AND G) OR (s6 AND B AND s1 AND D AND E AND s5 AND G) OR (s6 AND B AND C AND s2 AND s3 AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s5 AND s4) OR (s6 AND B AND D AND E AND F AND s4) OR (s6 AND B AND C AND D AND E AND F));
  aluop0 <= ((s6 AND s0 AND s1 AND D AND E AND F AND s4) OR (s6 AND s0 AND C AND s2 AND s3 AND s5 AND G) OR (s6 AND s0 AND C AND s2 AND s3 AND F AND s4) OR (s6 AND s0 AND C AND D AND E AND F AND G) OR (s6 AND s1 AND s2 AND s3 AND F AND G) OR (s6 AND s0 AND s1 AND E AND s5 AND G) OR (s6 AND B AND s1 AND s2 AND F));
  aluop1 <= ((s6 AND s0 AND C AND D AND s3 AND F AND G) OR (A AND s0 AND s1 AND s2 AND E AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s6 AND B AND s1 AND D AND s3 AND s4) OR (s6 AND s0 AND C AND D AND E AND s5) OR (s6 AND B AND s1 AND D AND s3 AND s5) OR (s6 AND B AND s1 AND s2 AND E));
  aluop2 <= ((s6 AND B AND s1 AND D AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND E AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s6 AND s0 AND s2 AND E AND F AND G) OR (s6 AND s0 AND D AND s3 AND s5 AND s4) OR (s6 AND s0 AND C AND s3 AND F AND G) OR (s6 AND s0 AND C AND s2 AND E AND F) OR (s6 AND s0 AND C AND D AND s5) OR (s6 AND s0 AND C AND D AND s3));
  aluop3 <= ((s6 AND s0 AND D AND E AND F AND G) OR (s6 AND s0 AND C AND D AND F AND s4) OR (s6 AND s0 AND s2 AND E AND s5) OR (s6 AND B AND s1 AND s3 AND s5) OR (s6 AND s0 AND C AND s2 AND s3) OR (s6 AND B AND s1 AND s2 AND s3) OR (s0 AND s1 AND s2 AND E AND s5 AND G) OR (s0 AND s1 AND s2 AND E AND F AND s4));
  aluop4 <= ((s6 AND B AND C AND s2 AND s3 AND s5 AND G) OR (s6 AND B AND C AND s2 AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND s3 AND s5 AND s4) OR (s6 AND s1 AND D AND E AND s5 AND s4) OR (s6 AND s0 AND s1 AND E AND F AND s4) OR (s6 AND s0 AND s1 AND s2 AND F AND s4) OR (s6 AND s0 AND C AND D AND s3 AND G) OR (s6 AND B AND s1 AND s2 AND E AND G) OR (s6 AND B AND s1 AND D AND s3 AND G) OR (s6 AND s0 AND s3 AND F AND G) OR (s6 AND s0 AND D AND s5 AND s4) OR (s6 AND s0 AND D AND E AND s5) OR (s6 AND s0 AND C AND E AND s5) OR (s0 AND s1 AND s2 AND s3 AND F AND G));
  WE <= ((s6 AND D AND s3 AND F AND s4) OR (s6 AND s1 AND E AND s5 AND s4) OR (s6 AND s1 AND E AND F AND G) OR (s6 AND C AND s2 AND s3 AND s4) OR (s6 AND s1 AND D AND s3 AND s5) OR (s6 AND C AND s2 AND s3 AND F) OR (s6 AND s0 AND D AND s5) OR (s6 AND s1 AND s2 AND E) OR (s6 AND s0 AND D AND s3) OR (s6 AND s0 AND s1 AND D) OR (s6 AND s0 AND C AND s2) OR (s0 AND s1 AND D AND s3 AND s5 AND s4) OR (s0 AND s1 AND s2 AND G) OR (s0 AND s1 AND s2 AND F));
  sf <= ((s6 AND s1 AND D AND s3 AND s5 AND s4) OR (s6 AND s0 AND s2 AND F AND s4) OR (s6 AND s0 AND D AND F AND G) OR (s6 AND s0 AND s1 AND F AND G) OR (s6 AND s0 AND C AND s5) OR (s6 AND B AND s1 AND s2) OR (s6 AND s0 AND E) OR (s0 AND s1 AND s2 AND E AND s5 AND G) OR (s0 AND s1 AND s2 AND E AND F AND s4));
  alu2D <= ((s6 AND C AND s2 AND s3 AND F AND G) OR (s6 AND s1 AND D AND s3 AND s4) OR (s6 AND s1 AND D AND s3 AND s5) OR (s6 AND s0 AND E AND s5) OR (s6 AND s0 AND s2 AND F) OR (s6 AND s0 AND s1 AND F) OR (s6 AND s1 AND s2 AND E) OR (s6 AND s0 AND C AND s3) OR (s0 AND s1 AND s2 AND E AND s5 AND G) OR (s0 AND s1 AND s2 AND E AND F AND s4));
  iem0 <= ((s6 AND s0 AND C AND s2 AND s3 AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s6 AND C AND D AND E AND s5 AND s4) OR (s6 AND s0 AND C AND D AND s5 AND s4) OR (s6 AND B AND C AND D AND F AND s4) OR (s6 AND s0 AND C AND s2 AND E AND s4) OR (s6 AND B AND s1 AND s2 AND s3 AND s4) OR (s6 AND s1 AND D AND E AND G) OR (s6 AND s0 AND s1 AND D AND G));
  iem1 <= ((s6 AND B AND s1 AND D AND E AND s5 AND G) OR (s6 AND B AND C AND D AND E AND F AND s4));
  br0 <= ((s6 AND B AND C AND s2 AND E AND F AND G) OR (s6 AND B AND C AND D AND s5 AND G) OR (s6 AND B AND C AND D AND s3 AND s5));
  br1 <= ((s6 AND B AND C AND s2 AND E AND s5 AND G) OR (s6 AND B AND C AND s2 AND E AND F AND s4) OR (s6 AND B AND C AND D AND s3 AND s5));
  br2 <= ((s6 AND B AND C AND D AND s3 AND s5 AND G) OR (s6 AND B AND C AND s2 AND E AND s4) OR (s6 AND B AND C AND s2 AND E AND F));
  muxA <= ((s6 AND B AND s1 AND D AND E AND s5 AND s4) OR (s6 AND B AND C AND s2 AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND F));
  ld <= ((s6 AND B AND s1 AND D AND E AND s5 AND s4) OR (s6 AND B AND s1 AND D AND E AND F AND G) OR (s6 AND B AND C AND s2 AND s3 AND s4));
  st <= ((s6 AND B AND s1 AND D AND s3 AND F AND G) OR (s6 AND B AND s1 AND D AND E AND s5 AND G) OR (s6 AND B AND s1 AND D AND E AND F AND s4) OR (s6 AND B AND C AND s2 AND s3 AND s5 AND G));
  p_abs <= ((s6 AND B AND C AND D AND E AND s5 AND s4) OR (A AND s0 AND s1 AND s2 AND E AND s5 AND s4) OR (s6 AND B AND C AND D AND s3 AND F));
  ioW <= ((A AND s0 AND s1 AND s2 AND s3 AND s5 AND s4) OR (s6 AND B AND C AND D AND E AND F));
  ioR <= ((A AND s0 AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND F));
  stPC <= (s6 AND B AND C AND D AND s3 AND F AND s4);
  Reti <= (A AND s0 AND s1 AND s2 AND E AND s5 AND s4);
  randomSel <= (A AND s0 AND s1 AND s2 AND E AND F AND G);
  timerSel <= (A AND s0 AND s1 AND D AND s3 AND s5 AND s4);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_2 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (1 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic );
end MUX_GATE_2;

architecture Behavioral of MUX_GATE_2 is
begin
  with sel select
    p_out <=
      in_0 when "00",
      in_1 when "01",
      in_2 when "10",
      in_3 when "11",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Register for storing large constants.
-- There is a 1-bit command describing this register. 
-- In this way, 15 bits can be stored (the 16th bit 
-- activates the writing of this register and therefore 
-- is always one). The 16th bit will be set according 
-- to the 'immediate extend mode' (iem).
entity ImReg is
  port (
    en: in std_logic; -- enables storage
    iem: in std_logic_vector(1 downto 0); -- immediate extend mode (0: sign extend; 1: extend with 0, 2:extend with S0, 3:extend with D0)
    C: in std_logic;
    inst: in std_logic_vector(15 downto 0); -- the current instruction
    imm: out std_logic_vector(15 downto 0) -- The constant of register contents and bit 8.
    );
end ImReg;

architecture Behavioral of ImReg is
  signal s0: std_logic_vector(14 downto 0);
  signal s1: std_logic_vector(14 downto 0);
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
begin
  s2 <= inst(0);
  s3 <= inst(4);
  s0 <= inst(14 downto 0);
  gate0: entity work.DIG_Register_BUS -- imm
    generic map (
      Bits => 15)
    port map (
      D => s0,
      C => C,
      en => en,
      Q => s1);
  s5 <= s1(14);
  gate1: entity work.MUX_GATE_2
    port map (
      sel => iem,
      in_0 => s5,
      in_1 => '0',
      in_2 => s2,
      in_3 => s3,
      p_out => s4);
  imm(14 downto 0) <= s1;
  imm(15) <= s4;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_3 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (2 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0);
    in_4: in std_logic_vector ((Bits-1) downto 0);
    in_5: in std_logic_vector ((Bits-1) downto 0);
    in_6: in std_logic_vector ((Bits-1) downto 0);
    in_7: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_3;

architecture Behavioral of MUX_GATE_BUS_3 is
begin
  with sel select
    p_out <=
      in_0 when "000",
      in_1 when "001",
      in_2 when "010",
      in_3 when "011",
      in_4 when "100",
      in_5 when "101",
      in_6 when "110",
      in_7 when "111",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DIG_RAMDualPort is
  generic (
    Bits : integer;       
    AddrBits : integer ); 
  port (
    D: out std_logic_vector ((Bits-1) downto 0);
    A: in std_logic_vector ((AddrBits-1) downto 0);
    Din: in std_logic_vector ((Bits-1) downto 0);
    str: in std_logic;
    C: in std_logic;
    ld: in std_logic );
end DIG_RAMDualPort;

architecture Behavioral of DIG_RAMDualPort is
    -- CAUTION: uses distributed RAM
    type memoryType is array(0 to (2**AddrBits)-1) of STD_LOGIC_VECTOR((Bits-1) downto 0);
    signal memory : memoryType;
begin
  process ( C )
  begin
    if rising_edge(C) AND (str='1') then
      memory(to_integer(unsigned(A))) <= Din;
    end if;
  end process;
  D <= memory(to_integer(unsigned(A))) when ld='1' else (others => 'Z');
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register is
  
  port (
    Q: out std_logic;
    D: in std_logic;
    C: in std_logic;
    en: in std_logic );
end DIG_Register;

architecture Behavioral of DIG_Register is
  signal state : std_logic := '0';
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DEMUX_GATE_4 is
  generic (
    Default : integer );
  port (
    out_0: out std_logic;
    out_1: out std_logic;
    out_2: out std_logic;
    out_3: out std_logic;
    out_4: out std_logic;
    out_5: out std_logic;
    out_6: out std_logic;
    out_7: out std_logic;
    out_8: out std_logic;
    out_9: out std_logic;
    out_10: out std_logic;
    out_11: out std_logic;
    out_12: out std_logic;
    out_13: out std_logic;
    out_14: out std_logic;
    out_15: out std_logic;
    sel: in std_logic_vector (3 downto 0);
    p_in: in std_logic );
end DEMUX_GATE_4;

architecture Behavioral of DEMUX_GATE_4 is
begin
    out_0 <= p_in when sel = "0000" else std_logic(to_unsigned(Default, 1)(0));
    out_1 <= p_in when sel = "0001" else std_logic(to_unsigned(Default, 1)(0));
    out_2 <= p_in when sel = "0010" else std_logic(to_unsigned(Default, 1)(0));
    out_3 <= p_in when sel = "0011" else std_logic(to_unsigned(Default, 1)(0));
    out_4 <= p_in when sel = "0100" else std_logic(to_unsigned(Default, 1)(0));
    out_5 <= p_in when sel = "0101" else std_logic(to_unsigned(Default, 1)(0));
    out_6 <= p_in when sel = "0110" else std_logic(to_unsigned(Default, 1)(0));
    out_7 <= p_in when sel = "0111" else std_logic(to_unsigned(Default, 1)(0));
    out_8 <= p_in when sel = "1000" else std_logic(to_unsigned(Default, 1)(0));
    out_9 <= p_in when sel = "1001" else std_logic(to_unsigned(Default, 1)(0));
    out_10 <= p_in when sel = "1010" else std_logic(to_unsigned(Default, 1)(0));
    out_11 <= p_in when sel = "1011" else std_logic(to_unsigned(Default, 1)(0));
    out_12 <= p_in when sel = "1100" else std_logic(to_unsigned(Default, 1)(0));
    out_13 <= p_in when sel = "1101" else std_logic(to_unsigned(Default, 1)(0));
    out_14 <= p_in when sel = "1110" else std_logic(to_unsigned(Default, 1)(0));
    out_15 <= p_in when sel = "1111" else std_logic(to_unsigned(Default, 1)(0));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_4 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (3 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0);
    in_4: in std_logic_vector ((Bits-1) downto 0);
    in_5: in std_logic_vector ((Bits-1) downto 0);
    in_6: in std_logic_vector ((Bits-1) downto 0);
    in_7: in std_logic_vector ((Bits-1) downto 0);
    in_8: in std_logic_vector ((Bits-1) downto 0);
    in_9: in std_logic_vector ((Bits-1) downto 0);
    in_10: in std_logic_vector ((Bits-1) downto 0);
    in_11: in std_logic_vector ((Bits-1) downto 0);
    in_12: in std_logic_vector ((Bits-1) downto 0);
    in_13: in std_logic_vector ((Bits-1) downto 0);
    in_14: in std_logic_vector ((Bits-1) downto 0);
    in_15: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_4;

architecture Behavioral of MUX_GATE_BUS_4 is
begin
  with sel select
    p_out <=
      in_0 when "0000",
      in_1 when "0001",
      in_2 when "0010",
      in_3 when "0011",
      in_4 when "0100",
      in_5 when "0101",
      in_6 when "0110",
      in_7 when "0111",
      in_8 when "1000",
      in_9 when "1001",
      in_10 when "1010",
      in_11 when "1011",
      in_12 when "1100",
      in_13 when "1101",
      in_14 when "1110",
      in_15 when "1111",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity RegisterBlock is
  port (
    DataIn: in std_logic_vector(15 downto 0);
    WE: in std_logic;
    clk: in std_logic;
    src: in std_logic_vector(3 downto 0);
    Dest: in std_logic_vector(3 downto 0);
    RDest: out std_logic_vector(15 downto 0);
    Rsrc: out std_logic_vector(15 downto 0));
end RegisterBlock;

architecture Behavioral of RegisterBlock is
  signal s0: std_logic;
  signal s1: std_logic_vector(15 downto 0);
  signal s2: std_logic;
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic;
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic;
  signal s7: std_logic_vector(15 downto 0);
  signal s8: std_logic;
  signal s9: std_logic_vector(15 downto 0);
  signal s10: std_logic;
  signal s11: std_logic_vector(15 downto 0);
  signal s12: std_logic;
  signal s13: std_logic_vector(15 downto 0);
  signal s14: std_logic;
  signal s15: std_logic_vector(15 downto 0);
  signal s16: std_logic;
  signal s17: std_logic_vector(15 downto 0);
  signal s18: std_logic;
  signal s19: std_logic_vector(15 downto 0);
  signal s20: std_logic;
  signal s21: std_logic_vector(15 downto 0);
  signal s22: std_logic;
  signal s23: std_logic_vector(15 downto 0);
  signal s24: std_logic;
  signal s25: std_logic_vector(15 downto 0);
  signal s26: std_logic;
  signal s27: std_logic_vector(15 downto 0);
  signal s28: std_logic;
  signal s29: std_logic_vector(15 downto 0);
  signal s30: std_logic;
  signal s31: std_logic_vector(15 downto 0);
begin
  gate0: entity work.DEMUX_GATE_4
    generic map (
      Default => 0)
    port map (
      sel => Dest,
      p_in => WE,
      out_0 => s0,
      out_1 => s2,
      out_2 => s4,
      out_3 => s6,
      out_4 => s8,
      out_5 => s10,
      out_6 => s12,
      out_7 => s14,
      out_8 => s16,
      out_9 => s18,
      out_10 => s20,
      out_11 => s22,
      out_12 => s24,
      out_13 => s26,
      out_14 => s28,
      out_15 => s30);
  gate1: entity work.DIG_Register_BUS -- R0
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s0,
      Q => s1);
  gate2: entity work.DIG_Register_BUS -- R1
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s2,
      Q => s3);
  gate3: entity work.DIG_Register_BUS -- R2
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s4,
      Q => s5);
  gate4: entity work.DIG_Register_BUS -- R3
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s6,
      Q => s7);
  gate5: entity work.DIG_Register_BUS -- R4
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s8,
      Q => s9);
  gate6: entity work.DIG_Register_BUS -- R5
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s10,
      Q => s11);
  gate7: entity work.DIG_Register_BUS -- R6
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s12,
      Q => s13);
  gate8: entity work.DIG_Register_BUS -- R7
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s14,
      Q => s15);
  gate9: entity work.DIG_Register_BUS -- R8
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s16,
      Q => s17);
  gate10: entity work.DIG_Register_BUS -- R9
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s18,
      Q => s19);
  gate11: entity work.DIG_Register_BUS -- R10
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s20,
      Q => s21);
  gate12: entity work.DIG_Register_BUS -- R11
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s22,
      Q => s23);
  gate13: entity work.DIG_Register_BUS -- R12
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s24,
      Q => s25);
  gate14: entity work.DIG_Register_BUS -- BP
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s26,
      Q => s27);
  gate15: entity work.DIG_Register_BUS -- SP
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s28,
      Q => s29);
  gate16: entity work.DIG_Register_BUS -- RA
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s30,
      Q => s31);
  gate17: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel => Dest,
      in_0 => s1,
      in_1 => s3,
      in_2 => s5,
      in_3 => s7,
      in_4 => s9,
      in_5 => s11,
      in_6 => s13,
      in_7 => s15,
      in_8 => s17,
      in_9 => s19,
      in_10 => s21,
      in_11 => s23,
      in_12 => s25,
      in_13 => s27,
      in_14 => s29,
      in_15 => s31,
      p_out => RDest);
  gate18: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel => src,
      in_0 => s1,
      in_1 => s3,
      in_2 => s5,
      in_3 => s7,
      in_4 => s9,
      in_5 => s11,
      in_6 => s13,
      in_7 => s15,
      in_8 => s17,
      in_9 => s19,
      in_10 => s21,
      in_11 => s23,
      in_12 => s25,
      in_13 => s27,
      in_14 => s29,
      in_15 => s31,
      p_out => Rsrc);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_4 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (3 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic;
    in_4: in std_logic;
    in_5: in std_logic;
    in_6: in std_logic;
    in_7: in std_logic;
    in_8: in std_logic;
    in_9: in std_logic;
    in_10: in std_logic;
    in_11: in std_logic;
    in_12: in std_logic;
    in_13: in std_logic;
    in_14: in std_logic;
    in_15: in std_logic );
end MUX_GATE_4;

architecture Behavioral of MUX_GATE_4 is
begin
  with sel select
    p_out <=
      in_0 when "0000",
      in_1 when "0001",
      in_2 when "0010",
      in_3 when "0011",
      in_4 when "0100",
      in_5 when "0101",
      in_6 when "0110",
      in_7 when "0111",
      in_8 when "1000",
      in_9 when "1001",
      in_10 when "1010",
      in_11 when "1011",
      in_12 when "1100",
      in_13 when "1101",
      in_14 when "1110",
      in_15 when "1111",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_JK_FF is
  generic (Default : std_logic);  
  port (
    Q: out std_logic;
    notQ: out std_logic;
    J: in std_logic;
    C: in std_logic;
    K: in std_logic );
end DIG_JK_FF;

architecture Behavioral of DIG_JK_FF is
  signal temp: std_logic := Default;
begin
  process (C)
  begin
    if rising_edge(C) then
      if (J='0' and K='1') then
         temp <= '0';
      elsif (J='1' and K='0') then
         temp <= '1';
      elsif (J='1' and K='1') then
         temp <= not (temp);
      end if;
    end if;
  end process;
  Q <= temp;
  notQ <= NOT( temp );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_D_FF_AS is
  
  port (
    Q: out std_logic;
    notQ: out std_logic;
    Set: in std_logic;
    D: in std_logic;
    C: in std_logic;
    Clr: in std_logic );
end DIG_D_FF_AS;

architecture Behavioral of DIG_D_FF_AS is
   signal state : std_logic := '0';
begin
    process (Set, Clr, C)
    begin
        if (Set='1') then
            state <= NOT('0');
        elsif (Clr='1') then
            state <= '0';
        elsif rising_edge(C) then
            state <= D;
        end if;
    end process;

    Q <= state;
    notQ <= NOT( state );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_3 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (2 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic;
    in_4: in std_logic;
    in_5: in std_logic;
    in_6: in std_logic;
    in_7: in std_logic );
end MUX_GATE_3;

architecture Behavioral of MUX_GATE_3 is
begin
  with sel select
    p_out <=
      in_0 when "000",
      in_1 when "001",
      in_2 when "010",
      in_3 when "011",
      in_4 when "100",
      in_5 when "101",
      in_6 when "110",
      in_7 when "111",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_D_FF is
  generic (
    Default: std_logic ); 
  port ( D  : in std_logic;
         C  : in std_logic;
         Q  : out std_logic;
         notQ : out std_logic );
end DIG_D_FF;

architecture Behavioral of DIG_D_FF is
   signal state : std_logic := Default;
begin
   Q    <= state;
   notQ <= NOT( state );

   process(C)
   begin
      if rising_edge(C) then
        state  <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
entity COMP_GATE_SIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_SIGNED;

architecture Behavioral of COMP_GATE_SIGNED is
begin
  process(a, b)
  begin
    if (signed(a) > signed(b)) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (signed(a) < signed(b)) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DIG_Neg is
  generic ( Bits: integer ); 
  port (
    p_in: in std_logic_vector ((Bits-1) downto 0);
    p_out: out std_logic_vector ((Bits-1) downto 0) );
end DIG_Neg;

architecture Behavioral of DIG_Neg is
begin
    p_out <= std_logic_vector(-signed(p_in));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Add is
  generic ( Bits: integer ); 
  port (
    s: out std_logic_vector((Bits-1) downto 0);
    c_o: out std_logic;
    a: in std_logic_vector((Bits-1) downto 0);
    b: in std_logic_vector((Bits-1) downto 0);
    c_i: in std_logic );
end DIG_Add;

architecture Behavioral of DIG_Add is
   signal temp : std_logic_vector(Bits downto 0);
begin
   temp <= ('0' & a) + b + c_i;

   s    <= temp((Bits-1) downto 0);
   c_o  <= temp(Bits);
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Sub is
  generic ( Bits: integer ); 
  port (
    s: out std_logic_vector((Bits-1) downto 0);
    c_o: out std_logic;
    a: in std_logic_vector((Bits-1) downto 0);
    b: in std_logic_vector((Bits-1) downto 0);
    c_i: in std_logic );
end DIG_Sub;

architecture Behavioral of DIG_Sub is
   signal temp : std_logic_vector(Bits downto 0);
begin
   temp <= ('0' & a) - b - c_i;

   s    <= temp((Bits-1) downto 0);
   c_o  <= temp(Bits);
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity COMP_GATE_UNSIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_UNSIGNED;

architecture Behavioral of COMP_GATE_UNSIGNED is
begin
  process(a, b)
  begin
    if (a > b ) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (a < b) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_1 is
  port (
    p_out: out std_logic;
    sel: in std_logic;
    
    in_0: in std_logic;
    in_1: in std_logic );
end MUX_GATE_1;

architecture Behavioral of MUX_GATE_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

entity DIG_CounterPreset is
  generic ( Bits: integer;
            maxValue: integer );
  port (
    p_out : out std_logic_vector((Bits-1) downto 0);
    ovf : out std_logic;
    C   : in std_logic;
    en  : in std_logic;
    clr : in std_logic;
    dir : in std_logic;
    p_in  : in std_logic_vector((Bits-1) downto 0);
    ld  : in std_logic );
end DIG_CounterPreset;

architecture Behavioral of DIG_CounterPreset is
   signal count : std_logic_vector((Bits-1) downto 0) := (others => '0');

   function maxVal ( maxv : integer )
       return integer is variable m : integer;
   begin
      if (maxv = 0) then
        m := (2**Bits)-1;
      else
        m := maxv;
      end if;
      return m;
   end function maxVal;

begin
    process (C, en)
    begin
      if rising_edge(C) then
        if clr='1' then
          count <= (others => '0');
        elsif ld='1' then
          count <= p_in;
        elsif en='1' then
          if dir='0' then
            if count=maxVal(maxValue) then
              count <= (others => '0');
            else
              count <= count + 1;
            end if;
          else
            if count=0 then
              count <= std_logic_vector(to_unsigned(maxVal(maxValue), Bits));
            else
              count <= count - 1;
            end if;
          end if;
        end if;
      end if;
    end process;

    p_out <= count;
    ovf <= en when (count = maxVal(maxValue) and dir='0') OR
                   (count = 0 and dir='1') else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    ui_in: in std_logic_vector(7 downto 0);
    uio_in: in std_logic_vector(7 downto 0);
    ena: in std_logic;
    clk: in std_logic;
    rst_n: in std_logic;
    uo_out: out std_logic_vector(7 downto 0);
    uio_out: out std_logic_vector(7 downto 0);
    uio_oe: out std_logic_vector(7 downto 0));
end main;

architecture Behavioral of main is
  signal muxA: std_logic;
  signal s0: std_logic_vector(15 downto 0);
  signal s1: std_logic_vector(15 downto 0);
  signal s2: std_logic_vector(15 downto 0);
  signal muxB: std_logic_vector(2 downto 0);
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic_vector(15 downto 0);
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic_vector(15 downto 0);
  signal s7: std_logic_vector(15 downto 0);
  signal s8: std_logic_vector(15 downto 0);
  signal s9: std_logic_vector(3 downto 0);
  signal s10: std_logic_vector(3 downto 0);
  signal OPcode: std_logic_vector(7 downto 0);
  signal s11: std_logic_vector(4 downto 0);
  signal s12: std_logic;
  signal C: std_logic;
  signal s13: std_logic;
  signal s14: std_logic_vector(15 downto 0);
  signal s15: std_logic_vector(2 downto 0);
  signal s16: std_logic_vector(15 downto 0);
  signal s17: std_logic_vector(15 downto 0);
  signal Din: std_logic_vector(15 downto 0);
  signal s18: std_logic_vector(15 downto 0);
  signal timer_in: std_logic_vector(15 downto 0);
  signal RandomNUM: std_logic_vector(15 downto 0);
  signal s19: std_logic_vector(15 downto 0);
  signal s20: std_logic_vector(1 downto 0);
  signal s21: std_logic;
  signal s22: std_logic;
  signal s23: std_logic;
  signal s24: std_logic;
  signal s25: std_logic;
  signal br: std_logic_vector(2 downto 0);
  signal s26: std_logic;
  signal sf: std_logic;
  signal s27: std_logic;
  signal s28: std_logic;
  signal FlagOut: std_logic_vector(15 downto 0);
  signal WE: std_logic;
  signal imm: std_logic;
  signal iem: std_logic_vector(1 downto 0);
  signal s29: std_logic_vector(11 downto 0);
  signal s30: std_logic;
  signal pcOut: std_logic_vector(11 downto 0);
  signal s31: std_logic_vector(11 downto 0);
  signal s32: std_logic_vector(11 downto 0);
  signal s33: std_logic_vector(11 downto 0);
  signal p_abs: std_logic;
  signal s34: std_logic_vector(11 downto 0);
  signal s35: std_logic_vector(11 downto 0);
  signal s36: std_logic;
  signal ioW: std_logic;
  signal s37: std_logic;
  signal s38: std_logic_vector(3 downto 0);
  signal outputToOutside: std_logic_vector(3 downto 0);
  signal sel: std_logic_vector(3 downto 0);
  signal s39: std_logic_vector(15 downto 0);
  signal s40: std_logic_vector(15 downto 0);
  signal s41: std_logic_vector(15 downto 0);
  signal s42: std_logic_vector(15 downto 0);
  signal s43: std_logic_vector(15 downto 0);
  signal s44: std_logic_vector(15 downto 0);
  signal s45: std_logic_vector(15 downto 0);
  signal s46: std_logic_vector(15 downto 0);
  signal s47: std_logic_vector(15 downto 0);
  signal s48: std_logic_vector(15 downto 0);
  signal s49: std_logic_vector(15 downto 0);
  signal s50: std_logic_vector(15 downto 0);
  signal s51: std_logic;
  signal s52: std_logic;
  signal s53: std_logic;
  signal s54: std_logic;
  signal s55: std_logic;
  signal aluOp: std_logic_vector(4 downto 0);
  signal s56: std_logic;
  signal s57: std_logic;
  signal s58: std_logic;
  signal s59: std_logic;
  signal s60: std_logic;
  signal s61: std_logic;
  signal s62: std_logic_vector(15 downto 0);
  signal s63: std_logic_vector(15 downto 0);
  signal s64: std_logic;
  signal s65: std_logic;
  signal s66: std_logic;
  signal s67: std_logic;
  signal s68: std_logic;
  signal s69: std_logic;
  signal s70: std_logic;
  signal s71: std_logic;
  signal s72: std_logic;
  signal s73: std_logic;
  signal s74: std_logic;
  signal s75: std_logic;
  signal s76: std_logic;
  signal s77: std_logic;
  signal s78: std_logic;
  signal s79: std_logic;
  signal s80: std_logic;
  signal s81: std_logic;
  signal s82: std_logic;
  signal s83: std_logic;
  signal s84: std_logic;
  signal s85: std_logic;
  signal s86: std_logic;
  signal s87: std_logic;
  signal s88: std_logic;
  signal s89: std_logic;
  signal s90: std_logic;
  signal s91: std_logic;
  signal s92: std_logic;
  signal s93: std_logic;
  signal s94: std_logic;
  signal s95: std_logic;
  signal s96: std_logic;
  signal s97: std_logic;
  signal s98: std_logic;
  signal s99: std_logic;
  signal stPC: std_logic;
  signal ld: std_logic;
  signal RandomNUMSel: std_logic;
  signal ioR: std_logic;
  signal s100: std_logic_vector(6 downto 0);
  signal s101: std_logic_vector(6 downto 0);
  signal s102: std_logic;
  signal s103: std_logic;
  signal s104: std_logic;
  signal s105: std_logic;
  signal s106: std_logic;
  signal s107: std_logic;
  signal s108: std_logic;
  signal s109: std_logic;
  signal s110: std_logic;
  signal s111: std_logic;
  signal src2D: std_logic;
  signal s112: std_logic;
  signal s113: std_logic;
  signal s114: std_logic;
  signal s115: std_logic;
  signal s116: std_logic;
  signal alu2D: std_logic;
  signal s117: std_logic;
  signal s118: std_logic;
  signal s119: std_logic;
  signal s120: std_logic;
  signal s121: std_logic;
  signal st: std_logic;
  signal Reti: std_logic;
  signal timer_Sel: std_logic;
  signal s122: std_logic;
  signal s123: std_logic;
  signal s124: std_logic_vector(3 downto 0);
  signal outputToOutsideEnable: std_logic_vector(3 downto 0);
  signal s125: std_logic;
  signal s126: std_logic;
  signal s127: std_logic_vector(7 downto 0);
  signal s128: std_logic;
  signal s129: std_logic_vector(7 downto 0);
  signal s130: std_logic_vector(1 downto 0);
  signal s131: std_logic;
  signal s132: std_logic;
  signal s133: std_logic;
  signal s134: std_logic;
  signal s135: std_logic;
  signal s136: std_logic_vector(2 downto 0);
  signal s137: std_logic_vector(2 downto 0);
  signal s138: std_logic;
  signal s139: std_logic;
  signal s140: std_logic;
  signal s141: std_logic;
  signal s142: std_logic;
  signal s143: std_logic;
  signal s144: std_logic_vector(7 downto 0);
  signal s145: std_logic;
  signal s146: std_logic;
  signal s147: std_logic;
  signal s148: std_logic;
  signal s149: std_logic;
  signal s150: std_logic;
  signal s151: std_logic;
  signal s152: std_logic;
  signal s153: std_logic_vector(2 downto 0);
  signal s154: std_logic;
  signal s155: std_logic_vector(1 downto 0);
  signal s156: std_logic;
  signal s157: std_logic;
  signal s158: std_logic_vector(15 downto 0);
  signal s159: std_logic;
  signal InterLock: std_logic;
  signal s160: std_logic;
  signal intr: std_logic;
  signal s161: std_logic;
  signal s162: std_logic;
  signal s163: std_logic;
  signal s164: std_logic;
  signal interEnable: std_logic;
  signal s165: std_logic;
  signal s166: std_logic_vector(15 downto 0);
  signal s167: std_logic;
  signal s168: std_logic;
  signal s169: std_logic_vector(11 downto 0);
  signal s170: std_logic;
  signal s171: std_logic_vector(11 downto 0);
  signal s172: std_logic;
  signal s173: std_logic_vector(11 downto 0);
  signal s174: std_logic;
  signal s175: std_logic;
  signal s176: std_logic_vector(15 downto 0);
  signal s177: std_logic_vector(15 downto 0);
  signal s178: std_logic;
  signal s179: std_logic;
  signal s180: std_logic;
  signal s181: std_logic;
  signal s182: std_logic;
  signal s183: std_logic;
  signal s184: std_logic;
  signal s185: std_logic;
  signal s186: std_logic;
  signal s187: std_logic;
  signal s188: std_logic;
begin
  Din(0) <= uio_in(0);
  Din(1) <= uio_in(1);
  Din(2) <= uio_in(2);
  Din(3) <= uio_in(3);
  Din(4) <= uio_in(4);
  Din(5) <= uio_in(5);
  Din(6) <= uio_in(6);
  Din(7) <= uio_in(7);
  Din(8) <= '0';
  Din(9) <= '0';
  Din(10) <= '0';
  Din(11) <= '0';
  Din(12) <= '0';
  Din(13) <= '0';
  Din(14) <= '0';
  Din(15) <= '0';
  s125 <= NOT clk;
  gate0: entity work.DIG_Counter
    generic map (
      Bits => 2)
    port map (
      en => '1',
      C => clk,
      clr => rst_n,
      p_out => s130,
      ovf => s133);
  s131 <= s130(0);
  s132 <= s130(1);
  s126 <= (s131 AND NOT s132);
  s128 <= (NOT s131 AND s132);
  C <= (s131 AND s132);
  s30 <= NOT C;
  gate1: entity work.DIG_Register_BUS
    generic map (
      Bits => 8)
    port map (
      D => ui_in,
      C => s125,
      en => s126,
      Q => s127);
  gate2: entity work.DIG_Register_BUS
    generic map (
      Bits => 8)
    port map (
      D => ui_in,
      C => s125,
      en => s128,
      Q => s129);
  gate3: entity work.DIG_Counter
    generic map (
      Bits => 8)
    port map (
      en => '0',
      C => C,
      clr => '0',
      p_out => s144);
  s162 <= NOT C;
  s164 <= NOT C;
  s170 <= NOT C;
  s8(7 downto 0) <= s129;
  s8(15 downto 8) <= s127;
  s145 <= s144(0);
  s146 <= s144(1);
  s147 <= s144(2);
  s148 <= s144(3);
  s149 <= s144(4);
  s150 <= s144(5);
  s151 <= s144(6);
  s152 <= s144(7);
  gate4: entity work.singExtend
    port map (
      inst => s8,
      n4S => s4,
      n8SD => s5,
      n4D => s6);
  s9 <= s8(3 downto 0);
  s10 <= s8(7 downto 4);
  OPcode <= s8(15 downto 8);
  s100 <= OPcode(6 downto 0);
  imm <= OPcode(7);
  gate5: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 7)
    port map (
      sel => imm,
      in_0 => s100,
      in_1 => "0000000",
      p_out => s101);
  s108 <= s101(0);
  s107 <= s101(1);
  s106 <= s101(2);
  s105 <= s101(3);
  s104 <= s101(4);
  s103 <= s101(5);
  s102 <= s101(6);
  gate6: entity work.controllogic
    port map (
      A => s102,
      B => s103,
      C => s104,
      D => s105,
      E => s106,
      F => s107,
      G => s108,
      muxb0 => s109,
      muxb1 => s110,
      muxb2 => s111,
      src2D => src2D,
      aluop0 => s112,
      aluop1 => s113,
      aluop2 => s114,
      aluop3 => s115,
      aluop4 => s116,
      WE => WE,
      sf => sf,
      alu2D => alu2D,
      iem0 => s117,
      iem1 => s118,
      br0 => s119,
      br1 => s120,
      br2 => s121,
      muxA => muxA,
      ld => ld,
      st => st,
      p_abs => p_abs,
      ioW => ioW,
      ioR => ioR,
      stPC => stPC,
      Reti => Reti,
      randomSel => RandomNUMSel,
      timerSel => timer_Sel);
  s15(0) <= (stPC OR ld OR RandomNUMSel);
  s15(1) <= (ioR OR stPC);
  s15(2) <= (timer_Sel OR RandomNUMSel);
  muxB(0) <= s111;
  muxB(1) <= s110;
  muxB(2) <= s109;
  aluOp(0) <= s116;
  aluOp(1) <= s115;
  aluOp(2) <= s114;
  aluOp(3) <= s113;
  aluOp(4) <= s112;
  br(0) <= s121;
  br(1) <= s120;
  br(2) <= s119;
  iem(0) <= s118;
  iem(1) <= s117;
  gate7: entity work.ImReg
    port map (
      en => imm,
      iem => iem,
      C => C,
      inst => s8,
      imm => s3);
  s20 <= br(1 downto 0);
  sel <= aluOp(3 downto 0);
  gate8: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => muxA,
      in_0 => s0,
      in_1 => s1,
      p_out => s2);
  gate9: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel => muxB,
      in_0 => s1,
      in_1 => "0000000000000000",
      in_2 => s3,
      in_3 => "0000000000000000",
      in_4 => "0000000000000000",
      in_5 => s4,
      in_6 => s5,
      in_7 => s6,
      p_out => s7);
  gate10: entity work.DIG_RAMDualPort -- mem
    generic map (
      Bits => 16,
      AddrBits => 5)
    port map (
      A => s11,
      Din => s1,
      str => s12,
      C => C,
      ld => s13,
      D => s14);
  gate11: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel => s15,
      in_0 => s16,
      in_1 => s17,
      in_2 => Din,
      in_3 => s18,
      in_4 => timer_in,
      in_5 => RandomNUM,
      in_6 => "0000000000000000",
      in_7 => "0000000000000000",
      p_out => s19);
  gate12: entity work.MUX_GATE_2
    port map (
      sel => s20,
      in_0 => '0',
      in_1 => s21,
      in_2 => s22,
      in_3 => s23,
      p_out => s24);
  s25 <= (s24 XOR br(2));
  gate13: entity work.DIG_Register -- Carry
    port map (
      D => s26,
      C => C,
      en => sf,
      Q => s21);
  gate14: entity work.DIG_Register -- Zero
    port map (
      D => s27,
      C => C,
      en => sf,
      Q => s22);
  gate15: entity work.DIG_Register -- Neg
    port map (
      D => s28,
      C => C,
      en => sf,
      Q => s23);
  gate16: entity work.RegisterBlock
    port map (
      DataIn => s19,
      WE => WE,
      clk => C,
      src => s9,
      Dest => s10,
      RDest => s0,
      Rsrc => s1);
  gate17: entity work.DIG_Register_BUS -- PC
    generic map (
      Bits => 12)
    port map (
      D => s29,
      C => s30,
      en => '1',
      Q => pcOut);
  gate18: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 12)
    port map (
      sel => p_abs,
      in_0 => s33,
      in_1 => s34,
      p_out => s35);
  s37 <= (s36 AND ioW);
  gate19: entity work.DIG_Register_BUS
    generic map (
      Bits => 4)
    port map (
      D => s38,
      C => C,
      en => s37,
      Q => outputToOutside);
  gate20: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel => sel,
      in_0 => s7,
      in_1 => s39,
      in_2 => s40,
      in_3 => s41,
      in_4 => s42,
      in_5 => s43,
      in_6 => s44,
      in_7 => s45,
      in_8 => s46,
      in_9 => s47,
      in_10 => s48,
      in_11 => s49,
      in_12 => s50,
      in_13 => "0000000000000000",
      in_14 => "0000000000000000",
      in_15 => "0000000000000000",
      p_out => s16);
  gate21: entity work.MUX_GATE_4
    port map (
      sel => sel,
      in_0 => '0',
      in_1 => s51,
      in_2 => s52,
      in_3 => '0',
      in_4 => '0',
      in_5 => '0',
      in_6 => '0',
      in_7 => '0',
      in_8 => s53,
      in_9 => s54,
      in_10 => s55,
      in_11 => '0',
      in_12 => '0',
      in_13 => '0',
      in_14 => '0',
      in_15 => '0',
      p_out => s26);
  s56 <= (aluOp(4) AND s21);
  gate22: entity work.DIG_Register_BUS -- seed
    generic map (
      Bits => 16)
    port map (
      D => s1,
      C => C,
      en => s61,
      Q => s62);
  s61 <= (s64 AND ioW);
  gate23: entity work.DIG_JK_FF
    generic map (
      Default => '0')
    port map (
      J => s65,
      C => C,
      K => s65,
      Q => s59);
  gate24: entity work.DIG_D_FF_AS
    port map (
      Set => s67,
      D => s68,
      C => C,
      Clr => s66,
      Q => s69);
  gate25: entity work.DIG_D_FF_AS
    port map (
      Set => s70,
      D => s69,
      C => C,
      Clr => s66,
      Q => s71);
  gate26: entity work.DIG_D_FF_AS
    port map (
      Set => s72,
      D => s71,
      C => C,
      Clr => s66,
      Q => s73);
  gate27: entity work.DIG_D_FF_AS
    port map (
      Set => s74,
      D => s73,
      C => C,
      Clr => s66,
      Q => s75);
  gate28: entity work.DIG_D_FF_AS
    port map (
      Set => s76,
      D => s75,
      C => C,
      Clr => s66,
      Q => s77);
  gate29: entity work.DIG_D_FF_AS
    port map (
      Set => s78,
      D => s77,
      C => C,
      Clr => s66,
      Q => s79);
  gate30: entity work.DIG_D_FF_AS
    port map (
      Set => s80,
      D => s79,
      C => C,
      Clr => s66,
      Q => s81);
  gate31: entity work.DIG_D_FF_AS
    port map (
      Set => s82,
      D => s81,
      C => C,
      Clr => s66,
      Q => s83);
  gate32: entity work.DIG_D_FF_AS
    port map (
      Set => s84,
      D => s83,
      C => C,
      Clr => s66,
      Q => s85);
  gate33: entity work.DIG_D_FF_AS
    port map (
      Set => s86,
      D => s85,
      C => C,
      Clr => s66,
      Q => s87);
  gate34: entity work.DIG_D_FF_AS
    port map (
      Set => s88,
      D => s87,
      C => C,
      Clr => s66,
      Q => s89);
  gate35: entity work.DIG_D_FF_AS
    port map (
      Set => s90,
      D => s89,
      C => C,
      Clr => s66,
      Q => s91);
  gate36: entity work.DIG_D_FF_AS
    port map (
      Set => s92,
      D => s91,
      C => C,
      Clr => s66,
      Q => s93);
  gate37: entity work.DIG_D_FF_AS
    port map (
      Set => s94,
      D => s93,
      C => C,
      Clr => s66,
      Q => s95);
  gate38: entity work.DIG_D_FF_AS
    port map (
      Set => s96,
      D => s95,
      C => C,
      Clr => s66,
      Q => s97);
  gate39: entity work.DIG_D_FF_AS
    port map (
      Set => s98,
      D => s97,
      C => C,
      Clr => s66,
      Q => s99);
  s58 <= (C AND s61);
  s123 <= (s122 AND ioW);
  gate40: entity work.DIG_Register_BUS
    generic map (
      Bits => 4)
    port map (
      D => s124,
      C => C,
      en => s123,
      Q => outputToOutsideEnable);
  s135 <= (s134 AND ioW);
  gate41: entity work.DIG_Register_BUS -- prescaler
    generic map (
      Bits => 3)
    port map (
      D => s136,
      C => C,
      en => s135,
      Q => s137);
  s139 <= (s138 AND ioW);
  gate42: entity work.DIG_Register -- timer_is_active
    port map (
      D => s140,
      C => C,
      en => s139);
  gate43: entity work.DIG_JK_FF -- Reset
    generic map (
      Default => '0')
    port map (
      J => s142,
      C => C,
      K => '1',
      Q => s143);
  s142 <= (s1(0) AND (s141 AND ioW));
  gate44: entity work.MUX_GATE_3
    port map (
      sel => s153,
      in_0 => s145,
      in_1 => s146,
      in_2 => s147,
      in_3 => s148,
      in_4 => s149,
      in_5 => s150,
      in_6 => s151,
      in_7 => s152,
      p_out => s154);
  gate45: entity work.DIG_RAMDualPort -- mem
    generic map (
      Bits => 16,
      AddrBits => 2)
    port map (
      A => s155,
      Din => s1,
      str => s156,
      C => C,
      ld => s157,
      D => s158);
  s156 <= (s159 AND st);
  s157 <= (s159 AND ld);
  intr <= (NOT InterLock AND NOT imm AND s160 AND NOT '0');
  gate46: entity work.DIG_D_FF -- *
    generic map (
      Default => '0')
    port map (
      D => s161,
      C => s162,
      Q => InterLock);
  s161 <= ((InterLock AND NOT Reti) OR intr);
  gate47: entity work.DIG_D_FF -- *
    generic map (
      Default => '0')
    port map (
      D => s163,
      C => s164,
      Q => s160);
  s163 <= ((s160 AND NOT Reti) OR ((NOT InterLock AND (NOT s180 AND s178)) AND interEnable));
  gate48: entity work.DIG_Register_BUS -- intEn
    generic map (
      Bits => 16)
    port map (
      D => s1,
      C => C,
      en => s165,
      Q => s166);
  s165 <= (s167 AND ioW);
  gate49: entity work.DIG_Register_BUS
    generic map (
      Bits => 12)
    port map (
      D => s35,
      C => s170,
      en => s168,
      Q => s171);
  s172 <= (interEnable AND Reti);
  s175 <= (s174 AND ioW);
  gate50: entity work.DIG_Register_BUS -- target
    generic map (
      Bits => 16)
    port map (
      D => s1,
      C => C,
      en => s175,
      Q => s176);
  gate51: entity work.DIG_Register -- Reload
    port map (
      D => s181,
      C => C,
      en => s182,
      Q => s183);
  s182 <= (s184 AND ioW);
  s13 <= (ld AND NOT s159);
  s12 <= (st AND NOT s159);
  gate52: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 12)
    port map (
      sel => rst_n,
      in_0 => "000000000000",
      in_1 => s173,
      p_out => s29);
  FlagOut(0) <= s21;
  FlagOut(1) <= s22;
  FlagOut(2) <= s23;
  FlagOut(15 downto 3) <= "0000000000000";
  gate53: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s16,
      b => "0000000000001000",
      eq => s36);
  s41 <= (s2 AND s7);
  s42 <= (s2 OR s7);
  s43 <= (s2 XOR s7);
  gate54: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s16,
      b => "0000000000000000",
      eq => s27);
  s44 <= NOT s2;
  gate55: entity work.DIG_Neg
    generic map (
      Bits => 16)
    port map (
      p_in => s2,
      p_out => s45);
  gate56: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s61,
      in_0 => "0000000000000000",
      in_1 => s62,
      p_out => s63);
  gate57: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s16,
      b => "0000000000001000",
      eq => s64);
  s68 <= (s79 XOR (s89 XOR (s93 XOR s97)));
  RandomNUM(0) <= s69;
  RandomNUM(1) <= s71;
  RandomNUM(2) <= s73;
  RandomNUM(3) <= s75;
  RandomNUM(4) <= s77;
  RandomNUM(5) <= s79;
  RandomNUM(6) <= s81;
  RandomNUM(7) <= s83;
  RandomNUM(8) <= s85;
  RandomNUM(9) <= s87;
  RandomNUM(10) <= s89;
  RandomNUM(11) <= s91;
  RandomNUM(12) <= s93;
  RandomNUM(13) <= s95;
  RandomNUM(14) <= s97;
  RandomNUM(15) <= s99;
  gate58: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s16,
      b => "0000000000001001",
      eq => s122);
  uio_out(3 downto 0) <= pcOut(11 downto 8);
  uio_out(7 downto 4) <= outputToOutside;
  uio_oe(3 downto 0) <= "1111";
  uio_oe(7 downto 4) <= outputToOutsideEnable;
  gate59: entity work.DIG_Add
    generic map (
      Bits => 16)
    port map (
      a => s2,
      b => s7,
      c_i => s56,
      s => s39,
      c_o => s51);
  gate60: entity work.DIG_Sub
    generic map (
      Bits => 16)
    port map (
      a => s2,
      b => s7,
      c_i => s56,
      s => s40,
      c_o => s52);
  gate61: entity work.DIG_Add
    generic map (
      Bits => 12)
    port map (
      a => pcOut,
      b => "000000000001",
      c_i => '0',
      s => s31);
  gate62: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s16,
      b => "0000000000000010",
      eq => s134);
  gate63: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s16,
      b => "0000000000000001",
      eq => s138);
  gate64: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s16,
      b => "0000000000000110",
      eq => s141);
  gate65: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 16)
    port map (
      a => s16,
      b => "0000000000000111",
      eq => s167);
  gate66: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s16,
      b => "0000000000000011",
      eq => s174);
  gate67: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 16)
    port map (
      a => s176,
      b => "0000000000000000",
      gr => s179,
      eq => s180);
  gate68: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s16,
      b => "0000000000000101",
      eq => s184);
  s50(3 downto 0) <= s2(7 downto 4);
  s50(7 downto 4) <= s2(3 downto 0);
  s50(11 downto 8) <= s2(15 downto 12);
  s50(15 downto 12) <= s2(11 downto 8);
  s49(7 downto 0) <= s2(15 downto 8);
  s49(15 downto 8) <= s2(7 downto 0);
  s47(14 downto 0) <= s2(15 downto 1);
  s47(15) <= s56;
  s46(0) <= s56;
  s46(15 downto 1) <= s2(14 downto 0);
  s11 <= s16(4 downto 0);
  s38 <= s1(3 downto 0);
  s28 <= s16(15);
  s34 <= s16(11 downto 0);
  s124 <= s1(3 downto 0);
  uo_out <= pcOut(7 downto 0);
  s136 <= s1(2 downto 0);
  s140 <= s1(0);
  s155 <= s16(1 downto 0);
  s159 <= s16(5);
  interEnable <= s166(0);
  s181 <= s1(0);
  s55 <= s2(0);
  s188 <= s2(15);
  s54 <= s2(0);
  s53 <= s2(15);
  s18(11 downto 0) <= s31;
  s18(15 downto 12) <= "0000";
  gate69: entity work.DIG_Add
    generic map (
      Bits => 12)
    port map (
      a => s31,
      b => s34,
      c_i => '0',
      s => s32);
  gate70: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s159,
      in_0 => s14,
      in_1 => s158,
      p_out => s17);
  s168 <= (intr AND interEnable);
  gate71: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s179,
      in_0 => "0000000000000000",
      in_1 => s176,
      p_out => s177);
  s48(13 downto 0) <= s2(14 downto 1);
  s48(14) <= s188;
  s48(15) <= s188;
  s67 <= s63(0);
  s70 <= s63(1);
  s72 <= s63(2);
  s74 <= s63(3);
  s76 <= s63(4);
  s78 <= s63(5);
  s80 <= s63(6);
  s82 <= s63(7);
  s84 <= s63(8);
  s86 <= s63(9);
  s88 <= s63(10);
  s90 <= s63(11);
  s92 <= s63(12);
  s94 <= s63(13);
  s96 <= s63(14);
  s98 <= s63(15);
  gate72: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 12)
    port map (
      sel => s25,
      in_0 => s31,
      in_1 => s32,
      p_out => s33);
  gate73: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 12)
    port map (
      sel => s168,
      in_0 => s35,
      in_1 => "000000000010",
      p_out => s169);
  gate74: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 12)
    port map (
      sel => s172,
      in_0 => s169,
      in_1 => s171,
      p_out => s173);
  gate75: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s57,
      C => s58,
      Clr => s59,
      Q => s60,
      notQ => s57);
  s65 <= (s60 OR s59);
  s66 <= (s61 AND NOT s65);
  gate76: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 16)
    port map (
      a => s177,
      b => timer_in,
      eq => s178);
  s185 <= (NOT s180 AND ((s178 AND s183) OR s143));
  gate77: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 3)
    port map (
      sel => s185,
      in_0 => s137,
      in_1 => "000",
      p_out => s153);
  gate78: entity work.MUX_GATE_1
    port map (
      sel => s187,
      in_0 => s154,
      in_1 => '1',
      p_out => s186);
  s187 <= (InterLock OR ((s178 AND NOT s180) AND NOT s185));
  gate79: entity work.DIG_CounterPreset
    generic map (
      Bits => 16,
      maxValue => 0)
    port map (
      en => '0',
      C => s186,
      dir => '0',
      p_in => "0000000000000000",
      ld => s185,
      clr => '0',
      p_out => timer_in);
end Behavioral;
