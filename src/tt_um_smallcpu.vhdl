-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Counter is
  generic ( Bits: integer ); 
  port (
    p_out: out std_logic_vector((Bits-1) downto 0);
    ovf: out std_logic;
    C: in std_logic;
    en: in std_logic;
    clr: in std_logic );
end DIG_Counter;

architecture Behavioral of DIG_Counter is
   signal count : std_logic_vector((Bits-1) downto 0) := (others => '0');
begin
    process (C, clr, en)
    begin
      if rising_edge(C) then
        if clr='1' then
          count <= (others => '0');
        elsif en='1' then
          count <= count + 1;
        end if;
      end if;
    end process;

    p_out <= count;
    ovf <= en when count = ((2**Bits)-1) else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register_BUS is
  generic ( Bits: integer ); 
  port (
    Q: out std_logic_vector ((Bits-1) downto 0);
    D: in std_logic_vector ((Bits-1) downto 0);
    C: in std_logic;
    en: in std_logic );
end DIG_Register_BUS;

architecture Behavioral of DIG_Register_BUS is
  signal state : std_logic_vector ((Bits-1) downto 0) := (others => '0');
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity singExtend is
  port (
    inst: in std_logic_vector(15 downto 0); -- instruction word
    n4S: out std_logic_vector(15 downto 0); -- The four bits taken from Rs.
    n8SD: out std_logic_vector(15 downto 0); -- The eight bits taken from Rs,Rd with sign extension.
    n4D: out std_logic_vector(15 downto 0) -- The four bits taken from Rd.
    );
end singExtend;

architecture Behavioral of singExtend is
  signal s0: std_logic;
begin
  n4D(3 downto 0) <= inst(7 downto 4);
  n4D(15 downto 4) <= "000000000000";
  n4S(3 downto 0) <= inst(3 downto 0);
  n4S(15 downto 4) <= "000000000000";
  s0 <= inst(7);
  n8SD(6 downto 0) <= inst(6 downto 0);
  n8SD(7) <= s0;
  n8SD(8) <= s0;
  n8SD(9) <= s0;
  n8SD(10) <= s0;
  n8SD(11) <= s0;
  n8SD(12) <= s0;
  n8SD(13) <= s0;
  n8SD(14) <= s0;
  n8SD(15) <= s0;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_1 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic;
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_1;

architecture Behavioral of MUX_GATE_BUS_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity controllogic is
  port (
    A: in std_logic;
    B: in std_logic;
    C: in std_logic;
    D: in std_logic;
    E: in std_logic;
    F: in std_logic;
    G: in std_logic;
    muxb0: out std_logic;
    muxb1: out std_logic;
    muxb2: out std_logic;
    src2D: out std_logic;
    aluop0: out std_logic;
    aluop1: out std_logic;
    aluop2: out std_logic;
    aluop3: out std_logic;
    aluop4: out std_logic;
    WE: out std_logic;
    sf: out std_logic;
    alu2D: out std_logic;
    iem0: out std_logic;
    iem1: out std_logic;
    br0: out std_logic;
    br1: out std_logic;
    br2: out std_logic;
    muxA: out std_logic;
    ld: out std_logic;
    st: out std_logic;
    p_abs: out std_logic;
    ioW: out std_logic;
    ioR: out std_logic;
    stPC: out std_logic;
    Reti: out std_logic;
    randomSel: out std_logic;
    timerSel: out std_logic);
end controllogic;

architecture Behavioral of controllogic is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
begin
  s6 <= NOT A;
  s0 <= NOT B;
  s1 <= NOT C;
  s2 <= NOT D;
  s3 <= NOT E;
  s5 <= NOT F;
  s4 <= NOT G;
  muxb0 <= ((A AND s0 AND s1 AND s2 AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND E AND F AND G) OR (A AND s0 AND s1 AND D AND s3 AND s5 AND s4) OR (s6 AND s1 AND D AND E AND F AND s4) OR (s6 AND B AND C AND s3 AND s5 AND s4) OR (s6 AND s0 AND s1 AND D AND F AND s4) OR (s6 AND s0 AND s1 AND D AND E AND s4) OR (s6 AND s0 AND C AND s2 AND s3 AND s4) OR (s6 AND B AND s1 AND s2 AND s3 AND G) OR (s6 AND C AND D AND s5 AND G) OR (s6 AND C AND s2 AND E AND G) OR (s6 AND B AND C AND E AND G) OR (s6 AND B AND C AND s2 AND E));
  muxb1 <= ((A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s6 AND C AND s2 AND s3 AND s5 AND G) OR (s6 AND B AND s1 AND s2 AND s3 AND s4) OR (A AND s0 AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s5) OR (s6 AND s1 AND D AND F AND G) OR (s6 AND C AND D AND s5 AND s4) OR (s6 AND B AND C AND s5 AND G) OR (s6 AND B AND C AND F AND s4) OR (s6 AND C AND s2 AND E AND s4) OR (s6 AND s0 AND s1 AND D AND G) OR (s6 AND B AND D AND E) OR (s6 AND B AND C AND E));
  muxb2 <= ((s6 AND B AND C AND D AND E AND F AND G) OR (s6 AND C AND s2 AND s3 AND s5 AND s4) OR (s6 AND B AND s2 AND s3 AND F AND G) OR (s6 AND B AND s1 AND s3 AND F AND G) OR (A AND s0 AND s1 AND s3 AND s5 AND s4) OR (s6 AND s0 AND s1 AND D AND F AND s4) OR (s6 AND s0 AND C AND D AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND F AND G) OR (s6 AND s0 AND C AND s2 AND s3 AND s4) OR (s6 AND s0 AND C AND s2 AND E AND G) OR (s6 AND B AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s4) OR (s6 AND s1 AND D AND E AND s4));
  src2D <= ((s6 AND s0 AND s1 AND s2 AND s3 AND s5 AND G) OR (s6 AND B AND s1 AND D AND s3 AND F AND G) OR (s6 AND B AND s1 AND D AND E AND s5 AND G) OR (s6 AND B AND C AND s2 AND s3 AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s5 AND s4) OR (s6 AND B AND D AND E AND F AND s4) OR (s6 AND B AND C AND D AND E AND F));
  aluop0 <= ((s6 AND s0 AND s1 AND D AND E AND F AND s4) OR (s6 AND s0 AND C AND s2 AND s3 AND s5 AND G) OR (s6 AND s0 AND C AND s2 AND s3 AND F AND s4) OR (s6 AND s0 AND C AND D AND E AND F AND G) OR (s6 AND s1 AND s2 AND s3 AND F AND G) OR (s6 AND s0 AND s1 AND E AND s5 AND G) OR (s6 AND B AND s1 AND s2 AND F));
  aluop1 <= ((s6 AND s0 AND C AND D AND s3 AND F AND G) OR (A AND s0 AND s1 AND s2 AND E AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s6 AND B AND s1 AND D AND s3 AND s4) OR (s6 AND s0 AND C AND D AND E AND s5) OR (s6 AND B AND s1 AND D AND s3 AND s5) OR (s6 AND B AND s1 AND s2 AND E));
  aluop2 <= ((s6 AND B AND s1 AND D AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND E AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s6 AND s0 AND s2 AND E AND F AND G) OR (s6 AND s0 AND D AND s3 AND s5 AND s4) OR (s6 AND s0 AND C AND s3 AND F AND G) OR (s6 AND s0 AND C AND s2 AND E AND F) OR (s6 AND s0 AND C AND D AND s5) OR (s6 AND s0 AND C AND D AND s3));
  aluop3 <= ((s6 AND s0 AND D AND E AND F AND G) OR (s6 AND s0 AND C AND D AND F AND s4) OR (s6 AND s0 AND s2 AND E AND s5) OR (s6 AND B AND s1 AND s3 AND s5) OR (s6 AND s0 AND C AND s2 AND s3) OR (s6 AND B AND s1 AND s2 AND s3) OR (s0 AND s1 AND s2 AND E AND s5 AND G) OR (s0 AND s1 AND s2 AND E AND F AND s4));
  aluop4 <= ((s6 AND B AND C AND s2 AND s3 AND s5 AND G) OR (s6 AND B AND C AND s2 AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND s3 AND s5 AND s4) OR (s6 AND s1 AND D AND E AND s5 AND s4) OR (s6 AND s0 AND s1 AND E AND F AND s4) OR (s6 AND s0 AND s1 AND s2 AND F AND s4) OR (s6 AND s0 AND C AND D AND s3 AND G) OR (s6 AND B AND s1 AND s2 AND E AND G) OR (s6 AND B AND s1 AND D AND s3 AND G) OR (s6 AND s0 AND s3 AND F AND G) OR (s6 AND s0 AND D AND s5 AND s4) OR (s6 AND s0 AND D AND E AND s5) OR (s6 AND s0 AND C AND E AND s5) OR (s0 AND s1 AND s2 AND s3 AND F AND G));
  WE <= ((s6 AND D AND s3 AND F AND s4) OR (s6 AND s1 AND E AND s5 AND s4) OR (s6 AND s1 AND E AND F AND G) OR (s6 AND C AND s2 AND s3 AND s4) OR (s6 AND s1 AND D AND s3 AND s5) OR (s6 AND C AND s2 AND s3 AND F) OR (s6 AND s0 AND D AND s5) OR (s6 AND s1 AND s2 AND E) OR (s6 AND s0 AND D AND s3) OR (s6 AND s0 AND s1 AND D) OR (s6 AND s0 AND C AND s2) OR (s0 AND s1 AND D AND s3 AND s5 AND s4) OR (s0 AND s1 AND s2 AND G) OR (s0 AND s1 AND s2 AND F));
  sf <= ((s6 AND s1 AND D AND s3 AND s5 AND s4) OR (s6 AND s0 AND s2 AND F AND s4) OR (s6 AND s0 AND D AND F AND G) OR (s6 AND s0 AND s1 AND F AND G) OR (s6 AND s0 AND C AND s5) OR (s6 AND B AND s1 AND s2) OR (s6 AND s0 AND E) OR (s0 AND s1 AND s2 AND E AND s5 AND G) OR (s0 AND s1 AND s2 AND E AND F AND s4));
  alu2D <= ((s6 AND C AND s2 AND s3 AND F AND G) OR (s6 AND s1 AND D AND s3 AND s4) OR (s6 AND s1 AND D AND s3 AND s5) OR (s6 AND s0 AND E AND s5) OR (s6 AND s0 AND s2 AND F) OR (s6 AND s0 AND s1 AND F) OR (s6 AND s1 AND s2 AND E) OR (s6 AND s0 AND C AND s3) OR (s0 AND s1 AND s2 AND E AND s5 AND G) OR (s0 AND s1 AND s2 AND E AND F AND s4));
  iem0 <= ((s6 AND s0 AND C AND s2 AND s3 AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND s5 AND G) OR (A AND s0 AND s1 AND s2 AND E AND F AND s4) OR (s6 AND C AND D AND E AND s5 AND s4) OR (s6 AND s0 AND C AND D AND s5 AND s4) OR (s6 AND B AND C AND D AND F AND s4) OR (s6 AND s0 AND C AND s2 AND E AND s4) OR (s6 AND B AND s1 AND s2 AND s3 AND s4) OR (s6 AND s1 AND D AND E AND G) OR (s6 AND s0 AND s1 AND D AND G));
  iem1 <= ((s6 AND B AND s1 AND D AND E AND s5 AND G) OR (s6 AND B AND C AND D AND E AND F AND s4));
  br0 <= ((s6 AND B AND C AND s2 AND E AND F AND G) OR (s6 AND B AND C AND D AND s5 AND G) OR (s6 AND B AND C AND D AND s3 AND s5));
  br1 <= ((s6 AND B AND C AND s2 AND E AND s5 AND G) OR (s6 AND B AND C AND s2 AND E AND F AND s4) OR (s6 AND B AND C AND D AND s3 AND s5));
  br2 <= ((s6 AND B AND C AND D AND s3 AND s5 AND G) OR (s6 AND B AND C AND s2 AND E AND s4) OR (s6 AND B AND C AND s2 AND E AND F));
  muxA <= ((s6 AND B AND s1 AND D AND E AND s5 AND s4) OR (s6 AND B AND C AND s2 AND s3 AND F AND s4) OR (A AND s0 AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND F));
  ld <= ((s6 AND B AND s1 AND D AND E AND s5 AND s4) OR (s6 AND B AND s1 AND D AND E AND F AND G) OR (s6 AND B AND C AND s2 AND s3 AND s4));
  st <= ((s6 AND B AND s1 AND D AND s3 AND F AND G) OR (s6 AND B AND s1 AND D AND E AND s5 AND G) OR (s6 AND B AND s1 AND D AND E AND F AND s4) OR (s6 AND B AND C AND s2 AND s3 AND s5 AND G));
  p_abs <= ((s6 AND B AND C AND D AND E AND s5 AND s4) OR (A AND s0 AND s1 AND s2 AND E AND s5 AND s4) OR (s6 AND B AND C AND D AND s3 AND F));
  ioW <= ((A AND s0 AND s1 AND s2 AND s3 AND s5 AND s4) OR (s6 AND B AND C AND D AND E AND F));
  ioR <= ((A AND s0 AND s1 AND s2 AND s3 AND G) OR (A AND s0 AND s1 AND s2 AND s3 AND F));
  stPC <= (s6 AND B AND C AND D AND s3 AND F AND s4);
  Reti <= (A AND s0 AND s1 AND s2 AND E AND s5 AND s4);
  randomSel <= (A AND s0 AND s1 AND s2 AND E AND F AND G);
  timerSel <= (A AND s0 AND s1 AND D AND s3 AND s5 AND s4);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_2 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (1 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic );
end MUX_GATE_2;

architecture Behavioral of MUX_GATE_2 is
begin
  with sel select
    p_out <=
      in_0 when "00",
      in_1 when "01",
      in_2 when "10",
      in_3 when "11",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Register for storing large constants.
-- There is a 1-bit command describing this register. 
-- In this way, 15 bits can be stored (the 16th bit 
-- activates the writing of this register and therefore 
-- is always one). The 16th bit will be set according 
-- to the 'immediate extend mode' (iem).
entity ImReg is
  port (
    en: in std_logic; -- enables storage
    iem: in std_logic_vector(1 downto 0); -- immediate extend mode (0: sign extend; 1: extend with 0, 2:extend with S0, 3:extend with D0)
    C: in std_logic;
    inst: in std_logic_vector(15 downto 0); -- the current instruction
    imm: out std_logic_vector(15 downto 0) -- The constant of register contents and bit 8.
    );
end ImReg;

architecture Behavioral of ImReg is
  signal s0: std_logic_vector(14 downto 0);
  signal s1: std_logic_vector(14 downto 0);
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
begin
  s2 <= inst(0);
  s3 <= inst(4);
  s0 <= inst(14 downto 0);
  gate0: entity work.DIG_Register_BUS -- imm
    generic map (
      Bits => 15)
    port map (
      D => s0,
      C => C,
      en => en,
      Q => s1);
  s5 <= s1(14);
  gate1: entity work.MUX_GATE_2
    port map (
      sel => iem,
      in_0 => s5,
      in_1 => '0',
      in_2 => s2,
      in_3 => s3,
      p_out => s4);
  imm(14 downto 0) <= s1;
  imm(15) <= s4;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_3 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (2 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0);
    in_4: in std_logic_vector ((Bits-1) downto 0);
    in_5: in std_logic_vector ((Bits-1) downto 0);
    in_6: in std_logic_vector ((Bits-1) downto 0);
    in_7: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_3;

architecture Behavioral of MUX_GATE_BUS_3 is
begin
  with sel select
    p_out <=
      in_0 when "000",
      in_1 when "001",
      in_2 when "010",
      in_3 when "011",
      in_4 when "100",
      in_5 when "101",
      in_6 when "110",
      in_7 when "111",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DIG_RAMDualPort is
  generic (
    Bits : integer;       
    AddrBits : integer ); 
  port (
    D: out std_logic_vector ((Bits-1) downto 0);
    A: in std_logic_vector ((AddrBits-1) downto 0);
    Din: in std_logic_vector ((Bits-1) downto 0);
    str: in std_logic;
    C: in std_logic;
    ld: in std_logic );
end DIG_RAMDualPort;

architecture Behavioral of DIG_RAMDualPort is
    -- CAUTION: uses distributed RAM
    type memoryType is array(0 to (2**AddrBits)-1) of STD_LOGIC_VECTOR((Bits-1) downto 0);
    signal memory : memoryType;
begin
  process ( C )
  begin
    if rising_edge(C) AND (str='1') then
      memory(to_integer(unsigned(A))) <= Din;
    end if;
  end process;
  D <= memory(to_integer(unsigned(A))) when ld='1' else (others => 'Z');
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register is
  
  port (
    Q: out std_logic;
    D: in std_logic;
    C: in std_logic;
    en: in std_logic );
end DIG_Register;

architecture Behavioral of DIG_Register is
  signal state : std_logic := '0';
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DEMUX_GATE_4 is
  generic (
    Default : integer );
  port (
    out_0: out std_logic;
    out_1: out std_logic;
    out_2: out std_logic;
    out_3: out std_logic;
    out_4: out std_logic;
    out_5: out std_logic;
    out_6: out std_logic;
    out_7: out std_logic;
    out_8: out std_logic;
    out_9: out std_logic;
    out_10: out std_logic;
    out_11: out std_logic;
    out_12: out std_logic;
    out_13: out std_logic;
    out_14: out std_logic;
    out_15: out std_logic;
    sel: in std_logic_vector (3 downto 0);
    p_in: in std_logic );
end DEMUX_GATE_4;

architecture Behavioral of DEMUX_GATE_4 is
begin
    out_0 <= p_in when sel = "0000" else std_logic(to_unsigned(Default, 1)(0));
    out_1 <= p_in when sel = "0001" else std_logic(to_unsigned(Default, 1)(0));
    out_2 <= p_in when sel = "0010" else std_logic(to_unsigned(Default, 1)(0));
    out_3 <= p_in when sel = "0011" else std_logic(to_unsigned(Default, 1)(0));
    out_4 <= p_in when sel = "0100" else std_logic(to_unsigned(Default, 1)(0));
    out_5 <= p_in when sel = "0101" else std_logic(to_unsigned(Default, 1)(0));
    out_6 <= p_in when sel = "0110" else std_logic(to_unsigned(Default, 1)(0));
    out_7 <= p_in when sel = "0111" else std_logic(to_unsigned(Default, 1)(0));
    out_8 <= p_in when sel = "1000" else std_logic(to_unsigned(Default, 1)(0));
    out_9 <= p_in when sel = "1001" else std_logic(to_unsigned(Default, 1)(0));
    out_10 <= p_in when sel = "1010" else std_logic(to_unsigned(Default, 1)(0));
    out_11 <= p_in when sel = "1011" else std_logic(to_unsigned(Default, 1)(0));
    out_12 <= p_in when sel = "1100" else std_logic(to_unsigned(Default, 1)(0));
    out_13 <= p_in when sel = "1101" else std_logic(to_unsigned(Default, 1)(0));
    out_14 <= p_in when sel = "1110" else std_logic(to_unsigned(Default, 1)(0));
    out_15 <= p_in when sel = "1111" else std_logic(to_unsigned(Default, 1)(0));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_4 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (3 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0);
    in_4: in std_logic_vector ((Bits-1) downto 0);
    in_5: in std_logic_vector ((Bits-1) downto 0);
    in_6: in std_logic_vector ((Bits-1) downto 0);
    in_7: in std_logic_vector ((Bits-1) downto 0);
    in_8: in std_logic_vector ((Bits-1) downto 0);
    in_9: in std_logic_vector ((Bits-1) downto 0);
    in_10: in std_logic_vector ((Bits-1) downto 0);
    in_11: in std_logic_vector ((Bits-1) downto 0);
    in_12: in std_logic_vector ((Bits-1) downto 0);
    in_13: in std_logic_vector ((Bits-1) downto 0);
    in_14: in std_logic_vector ((Bits-1) downto 0);
    in_15: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_4;

architecture Behavioral of MUX_GATE_BUS_4 is
begin
  with sel select
    p_out <=
      in_0 when "0000",
      in_1 when "0001",
      in_2 when "0010",
      in_3 when "0011",
      in_4 when "0100",
      in_5 when "0101",
      in_6 when "0110",
      in_7 when "0111",
      in_8 when "1000",
      in_9 when "1001",
      in_10 when "1010",
      in_11 when "1011",
      in_12 when "1100",
      in_13 when "1101",
      in_14 when "1110",
      in_15 when "1111",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity RegisterBlock is
  port (
    DataIn: in std_logic_vector(15 downto 0);
    WE: in std_logic;
    clk: in std_logic;
    src: in std_logic_vector(3 downto 0);
    Dest: in std_logic_vector(3 downto 0);
    RDest: out std_logic_vector(15 downto 0);
    Rsrc: out std_logic_vector(15 downto 0));
end RegisterBlock;

architecture Behavioral of RegisterBlock is
  signal s0: std_logic;
  signal s1: std_logic_vector(15 downto 0);
  signal s2: std_logic;
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic;
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic;
  signal s7: std_logic_vector(15 downto 0);
  signal s8: std_logic;
  signal s9: std_logic_vector(15 downto 0);
  signal s10: std_logic;
  signal s11: std_logic_vector(15 downto 0);
  signal s12: std_logic;
  signal s13: std_logic_vector(15 downto 0);
  signal s14: std_logic;
  signal s15: std_logic_vector(15 downto 0);
  signal s16: std_logic;
  signal s17: std_logic_vector(15 downto 0);
  signal s18: std_logic;
  signal s19: std_logic_vector(15 downto 0);
  signal s20: std_logic;
  signal s21: std_logic_vector(15 downto 0);
  signal s22: std_logic;
  signal s23: std_logic_vector(15 downto 0);
  signal s24: std_logic;
  signal s25: std_logic_vector(15 downto 0);
  signal s26: std_logic;
  signal s27: std_logic_vector(15 downto 0);
  signal s28: std_logic;
  signal s29: std_logic_vector(15 downto 0);
  signal s30: std_logic;
  signal s31: std_logic_vector(15 downto 0);
begin
  gate0: entity work.DEMUX_GATE_4
    generic map (
      Default => 0)
    port map (
      sel => Dest,
      p_in => WE,
      out_0 => s0,
      out_1 => s2,
      out_2 => s4,
      out_3 => s6,
      out_4 => s8,
      out_5 => s10,
      out_6 => s12,
      out_7 => s14,
      out_8 => s16,
      out_9 => s18,
      out_10 => s20,
      out_11 => s22,
      out_12 => s24,
      out_13 => s26,
      out_14 => s28,
      out_15 => s30);
  gate1: entity work.DIG_Register_BUS -- R0
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s0,
      Q => s1);
  gate2: entity work.DIG_Register_BUS -- R1
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s2,
      Q => s3);
  gate3: entity work.DIG_Register_BUS -- R2
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s4,
      Q => s5);
  gate4: entity work.DIG_Register_BUS -- R3
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s6,
      Q => s7);
  gate5: entity work.DIG_Register_BUS -- R4
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s8,
      Q => s9);
  gate6: entity work.DIG_Register_BUS -- R5
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s10,
      Q => s11);
  gate7: entity work.DIG_Register_BUS -- R6
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s12,
      Q => s13);
  gate8: entity work.DIG_Register_BUS -- R7
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s14,
      Q => s15);
  gate9: entity work.DIG_Register_BUS -- R8
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s16,
      Q => s17);
  gate10: entity work.DIG_Register_BUS -- R9
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s18,
      Q => s19);
  gate11: entity work.DIG_Register_BUS -- R10
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s20,
      Q => s21);
  gate12: entity work.DIG_Register_BUS -- R11
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s22,
      Q => s23);
  gate13: entity work.DIG_Register_BUS -- R12
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s24,
      Q => s25);
  gate14: entity work.DIG_Register_BUS -- BP
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s26,
      Q => s27);
  gate15: entity work.DIG_Register_BUS -- SP
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s28,
      Q => s29);
  gate16: entity work.DIG_Register_BUS -- RA
    generic map (
      Bits => 16)
    port map (
      D => DataIn,
      C => clk,
      en => s30,
      Q => s31);
  gate17: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel => Dest,
      in_0 => s1,
      in_1 => s3,
      in_2 => s5,
      in_3 => s7,
      in_4 => s9,
      in_5 => s11,
      in_6 => s13,
      in_7 => s15,
      in_8 => s17,
      in_9 => s19,
      in_10 => s21,
      in_11 => s23,
      in_12 => s25,
      in_13 => s27,
      in_14 => s29,
      in_15 => s31,
      p_out => RDest);
  gate18: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel => src,
      in_0 => s1,
      in_1 => s3,
      in_2 => s5,
      in_3 => s7,
      in_4 => s9,
      in_5 => s11,
      in_6 => s13,
      in_7 => s15,
      in_8 => s17,
      in_9 => s19,
      in_10 => s21,
      in_11 => s23,
      in_12 => s25,
      in_13 => s27,
      in_14 => s29,
      in_15 => s31,
      p_out => Rsrc);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_4 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (3 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic;
    in_4: in std_logic;
    in_5: in std_logic;
    in_6: in std_logic;
    in_7: in std_logic;
    in_8: in std_logic;
    in_9: in std_logic;
    in_10: in std_logic;
    in_11: in std_logic;
    in_12: in std_logic;
    in_13: in std_logic;
    in_14: in std_logic;
    in_15: in std_logic );
end MUX_GATE_4;

architecture Behavioral of MUX_GATE_4 is
begin
  with sel select
    p_out <=
      in_0 when "0000",
      in_1 when "0001",
      in_2 when "0010",
      in_3 when "0011",
      in_4 when "0100",
      in_5 when "0101",
      in_6 when "0110",
      in_7 when "0111",
      in_8 when "1000",
      in_9 when "1001",
      in_10 when "1010",
      in_11 when "1011",
      in_12 when "1100",
      in_13 when "1101",
      in_14 when "1110",
      in_15 when "1111",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_JK_FF is
  generic (Default : std_logic);  
  port (
    Q: out std_logic;
    notQ: out std_logic;
    J: in std_logic;
    C: in std_logic;
    K: in std_logic );
end DIG_JK_FF;

architecture Behavioral of DIG_JK_FF is
  signal temp: std_logic := Default;
begin
  process (C)
  begin
    if rising_edge(C) then
      if (J='0' and K='1') then
         temp <= '0';
      elsif (J='1' and K='0') then
         temp <= '1';
      elsif (J='1' and K='1') then
         temp <= not (temp);
      end if;
    end if;
  end process;
  Q <= temp;
  notQ <= NOT( temp );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_D_FF_AS is
  
  port (
    Q: out std_logic;
    notQ: out std_logic;
    Set: in std_logic;
    D: in std_logic;
    C: in std_logic;
    Clr: in std_logic );
end DIG_D_FF_AS;

architecture Behavioral of DIG_D_FF_AS is
   signal state : std_logic := '0';
begin
    process (Set, Clr, C)
    begin
        if (Set='1') then
            state <= NOT('0');
        elsif (Clr='1') then
            state <= '0';
        elsif rising_edge(C) then
            state <= D;
        end if;
    end process;

    Q <= state;
    notQ <= NOT( state );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
entity COMP_GATE_SIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_SIGNED;

architecture Behavioral of COMP_GATE_SIGNED is
begin
  process(a, b)
  begin
    if (signed(a) > signed(b)) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (signed(a) < signed(b)) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Moves the data word to the left to higher bits, so it multiplies 
-- by two. The current carry bit is pushed in at the bottom, and 
-- the most significant bit is output as a carry bit.
entity LSL is
  port (
    Di: in std_logic_vector(15 downto 0); -- data input
    Ci: in std_logic; -- carry input
    Do: out std_logic_vector(15 downto 0); -- data output
    Co: out std_logic -- carry output
    );
end LSL;

architecture Behavioral of LSL is
begin
  Do(0) <= Ci;
  Do(15 downto 1) <= Di(14 downto 0);
  Co <= Di(15);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Shift right. So a division by two.
-- The carry bit is inserted at the top. And the least 
-- significant bit is output as a new carry bit.
entity LSR is
  port (
    Di: in std_logic_vector(15 downto 0); -- data input
    Ci: in std_logic; -- carry input
    Do: out std_logic_vector(15 downto 0); -- data output
    Co: out std_logic -- carry output
    );
end LSR;

architecture Behavioral of LSR is
begin
  Do(14 downto 0) <= Di(15 downto 1);
  Do(15) <= Ci;
  Co <= Di(0);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Arithmetic shift right. An unsigned division by two. 
-- The lower bit is output as the carry bit, while the 
-- uppermost bit remains unchanged in order to 
-- obtain the sign.
entity ASR is
  port (
    Di: in std_logic_vector(15 downto 0); -- data input
    C: out std_logic; -- carry output
    Do: out std_logic_vector(15 downto 0) -- data output
    );
end ASR;

architecture Behavioral of ASR is
  signal s0: std_logic;
begin
  C <= Di(0);
  s0 <= Di(15);
  Do(13 downto 0) <= Di(14 downto 1);
  Do(14) <= s0;
  Do(15) <= s0;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Swaps the high-byte and the low-byte.
entity SWAP is
  port (
    Di: in std_logic_vector(15 downto 0); -- data input
    Do: out std_logic_vector(15 downto 0) -- data output
    );
end SWAP;

architecture Behavioral of SWAP is
begin
  Do(7 downto 0) <= Di(15 downto 8);
  Do(15 downto 8) <= Di(7 downto 0);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- Swaps the 4-bit nibble in the high- and the low-byte.
entity SWAPN is
  port (
    Di: in std_logic_vector(15 downto 0); -- Data input
    Do: out std_logic_vector(15 downto 0) -- Data output
    );
end SWAPN;

architecture Behavioral of SWAPN is
begin
  Do(3 downto 0) <= Di(7 downto 4);
  Do(7 downto 4) <= Di(3 downto 0);
  Do(11 downto 8) <= Di(15 downto 12);
  Do(15 downto 12) <= Di(11 downto 8);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DIG_Neg is
  generic ( Bits: integer ); 
  port (
    p_in: in std_logic_vector ((Bits-1) downto 0);
    p_out: out std_logic_vector ((Bits-1) downto 0) );
end DIG_Neg;

architecture Behavioral of DIG_Neg is
begin
    p_out <= std_logic_vector(-signed(p_in));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Add is
  generic ( Bits: integer ); 
  port (
    s: out std_logic_vector((Bits-1) downto 0);
    c_o: out std_logic;
    a: in std_logic_vector((Bits-1) downto 0);
    b: in std_logic_vector((Bits-1) downto 0);
    c_i: in std_logic );
end DIG_Add;

architecture Behavioral of DIG_Add is
   signal temp : std_logic_vector(Bits downto 0);
begin
   temp <= ('0' & a) + b + c_i;

   s    <= temp((Bits-1) downto 0);
   c_o  <= temp(Bits);
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Sub is
  generic ( Bits: integer ); 
  port (
    s: out std_logic_vector((Bits-1) downto 0);
    c_o: out std_logic;
    a: in std_logic_vector((Bits-1) downto 0);
    b: in std_logic_vector((Bits-1) downto 0);
    c_i: in std_logic );
end DIG_Sub;

architecture Behavioral of DIG_Sub is
   signal temp : std_logic_vector(Bits downto 0);
begin
   temp <= ('0' & a) - b - c_i;

   s    <= temp((Bits-1) downto 0);
   c_o  <= temp(Bits);
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_3 is
  port (
    p_out: out std_logic;
    sel: in std_logic_vector (2 downto 0);
    
    in_0: in std_logic;
    in_1: in std_logic;
    in_2: in std_logic;
    in_3: in std_logic;
    in_4: in std_logic;
    in_5: in std_logic;
    in_6: in std_logic;
    in_7: in std_logic );
end MUX_GATE_3;

architecture Behavioral of MUX_GATE_3 is
begin
  with sel select
    p_out <=
      in_0 when "000",
      in_1 when "001",
      in_2 when "010",
      in_3 when "011",
      in_4 when "100",
      in_5 when "101",
      in_6 when "110",
      in_7 when "111",
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    ui_in: in std_logic_vector(7 downto 0);
    uio_in: in std_logic_vector(7 downto 0);
    ena: in std_logic;
    clk: in std_logic;
    rst_n: in std_logic;
    uo_out: out std_logic_vector(7 downto 0);
    uio_out: out std_logic_vector(7 downto 0);
    uio_oe: out std_logic_vector(7 downto 0));
end main;

architecture Behavioral of main is
  signal muxA: std_logic;
  signal s0: std_logic_vector(15 downto 0);
  signal s1: std_logic_vector(15 downto 0);
  signal s2: std_logic_vector(15 downto 0);
  signal muxB: std_logic_vector(2 downto 0);
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic_vector(15 downto 0);
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic_vector(15 downto 0);
  signal s7: std_logic_vector(15 downto 0);
  signal s8: std_logic_vector(15 downto 0);
  signal s9: std_logic_vector(3 downto 0);
  signal s10: std_logic_vector(3 downto 0);
  signal OPcode: std_logic_vector(7 downto 0);
  signal s11: std_logic_vector(4 downto 0);
  signal st: std_logic;
  signal s12: std_logic;
  signal ld: std_logic;
  signal s13: std_logic_vector(15 downto 0);
  signal WDmux: std_logic_vector(2 downto 0);
  signal s14: std_logic_vector(15 downto 0);
  signal s15: std_logic_vector(15 downto 0);
  signal Din: std_logic_vector(15 downto 0);
  signal s16: std_logic_vector(15 downto 0);
  signal timer_in: std_logic_vector(15 downto 0);
  signal RandomNUM: std_logic_vector(15 downto 0);
  signal s17: std_logic_vector(15 downto 0);
  signal s18: std_logic_vector(1 downto 0);
  signal s19: std_logic;
  signal s20: std_logic;
  signal s21: std_logic;
  signal s22: std_logic;
  signal s23: std_logic;
  signal br: std_logic_vector(2 downto 0);
  signal s24: std_logic;
  signal sf: std_logic;
  signal s25: std_logic;
  signal s26: std_logic;
  signal FlagOut: std_logic_vector(15 downto 0);
  signal WE: std_logic;
  signal imm: std_logic;
  signal iem: std_logic_vector(1 downto 0);
  signal s27: std_logic_vector(11 downto 0);
  signal s28: std_logic;
  signal pcOut: std_logic_vector(11 downto 0);
  signal s29: std_logic_vector(11 downto 0);
  signal s30: std_logic_vector(11 downto 0);
  signal s31: std_logic_vector(11 downto 0);
  signal p_abs: std_logic;
  signal s32: std_logic_vector(11 downto 0);
  signal s33: std_logic;
  signal ioW: std_logic;
  signal s34: std_logic;
  signal s35: std_logic_vector(3 downto 0);
  signal outputToOutside: std_logic_vector(3 downto 0);
  signal sel: std_logic_vector(3 downto 0);
  signal s36: std_logic_vector(15 downto 0);
  signal s37: std_logic_vector(15 downto 0);
  signal s38: std_logic_vector(15 downto 0);
  signal s39: std_logic_vector(15 downto 0);
  signal s40: std_logic_vector(15 downto 0);
  signal s41: std_logic_vector(15 downto 0);
  signal s42: std_logic_vector(15 downto 0);
  signal s43: std_logic_vector(15 downto 0);
  signal s44: std_logic_vector(15 downto 0);
  signal s45: std_logic_vector(15 downto 0);
  signal s46: std_logic_vector(15 downto 0);
  signal s47: std_logic_vector(15 downto 0);
  signal s48: std_logic;
  signal s49: std_logic;
  signal s50: std_logic;
  signal s51: std_logic;
  signal s52: std_logic;
  signal aluOp: std_logic_vector(4 downto 0);
  signal s53: std_logic;
  signal s54: std_logic;
  signal s55: std_logic;
  signal s56: std_logic;
  signal s57: std_logic;
  signal s58: std_logic;
  signal s59: std_logic_vector(15 downto 0);
  signal s60: std_logic_vector(15 downto 0);
  signal s61: std_logic;
  signal s62: std_logic;
  signal s63: std_logic;
  signal s64: std_logic;
  signal s65: std_logic;
  signal s66: std_logic;
  signal s67: std_logic;
  signal s68: std_logic;
  signal s69: std_logic;
  signal s70: std_logic;
  signal s71: std_logic;
  signal s72: std_logic;
  signal s73: std_logic;
  signal s74: std_logic;
  signal s75: std_logic;
  signal s76: std_logic;
  signal s77: std_logic;
  signal s78: std_logic;
  signal s79: std_logic;
  signal s80: std_logic;
  signal s81: std_logic;
  signal s82: std_logic;
  signal s83: std_logic;
  signal s84: std_logic;
  signal s85: std_logic;
  signal s86: std_logic;
  signal s87: std_logic;
  signal s88: std_logic;
  signal s89: std_logic;
  signal s90: std_logic;
  signal s91: std_logic;
  signal s92: std_logic;
  signal s93: std_logic;
  signal s94: std_logic;
  signal s95: std_logic;
  signal s96: std_logic;
  signal stPC: std_logic;
  signal RandomNUMSel: std_logic;
  signal ioR: std_logic;
  signal s97: std_logic_vector(6 downto 0);
  signal s98: std_logic_vector(6 downto 0);
  signal s99: std_logic;
  signal s100: std_logic;
  signal s101: std_logic;
  signal s102: std_logic;
  signal s103: std_logic;
  signal s104: std_logic;
  signal s105: std_logic;
  signal s106: std_logic;
  signal s107: std_logic;
  signal s108: std_logic;
  signal src2D: std_logic;
  signal s109: std_logic;
  signal s110: std_logic;
  signal s111: std_logic;
  signal s112: std_logic;
  signal s113: std_logic;
  signal alu2D: std_logic;
  signal s114: std_logic;
  signal s115: std_logic;
  signal s116: std_logic;
  signal s117: std_logic;
  signal s118: std_logic;
  signal Reti: std_logic;
  signal timer_Sel: std_logic;
  signal s119: std_logic;
  signal s120: std_logic;
  signal s121: std_logic_vector(3 downto 0);
  signal outputToOutsideEnable: std_logic_vector(3 downto 0);
  signal s122: std_logic;
  signal s123: std_logic;
  signal s124: std_logic_vector(7 downto 0);
  signal s125: std_logic;
  signal s126: std_logic_vector(7 downto 0);
  signal s127: std_logic_vector(1 downto 0);
  signal s128: std_logic;
  signal s129: std_logic;
  signal s130: std_logic;
  signal s131: std_logic;
  signal s132: std_logic;
  signal s133: std_logic_vector(2 downto 0);
  signal s134: std_logic_vector(2 downto 0);
  signal s135: std_logic;
  signal s136: std_logic;
  signal s137: std_logic;
  signal s138: std_logic;
  signal s139: std_logic;
  signal s140: std_logic;
  signal s141: std_logic;
  signal s142: std_logic_vector(7 downto 0);
  signal s143: std_logic;
  signal s144: std_logic;
  signal s145: std_logic;
  signal s146: std_logic;
  signal s147: std_logic;
  signal s148: std_logic;
  signal s149: std_logic;
  signal s150: std_logic;
  signal s151: std_logic;
  signal s152: std_logic_vector(2 downto 0);
  signal s153: std_logic;
  signal s154: std_logic;
  signal s155: std_logic_vector(15 downto 0);
  signal s156: std_logic;
begin
  Din(0) <= uio_in(0);
  Din(1) <= uio_in(1);
  Din(2) <= uio_in(2);
  Din(3) <= uio_in(3);
  Din(4) <= uio_in(4);
  Din(5) <= uio_in(5);
  Din(6) <= uio_in(6);
  Din(7) <= uio_in(7);
  Din(8) <= '0';
  Din(9) <= '0';
  Din(10) <= '0';
  Din(11) <= '0';
  Din(12) <= '0';
  Din(13) <= '0';
  Din(14) <= '0';
  Din(15) <= '0';
  s122 <= NOT clk;
  gate0: entity work.DIG_Counter
    generic map (
      Bits => 2)
    port map (
      en => '1',
      C => clk,
      clr => rst_n,
      p_out => s127,
      ovf => s130);
  s128 <= s127(0);
  s129 <= s127(1);
  s123 <= (s128 AND NOT s129);
  s125 <= (NOT s128 AND s129);
  s12 <= (s128 AND s129);
  s28 <= NOT s12;
  gate1: entity work.DIG_Register_BUS
    generic map (
      Bits => 8)
    port map (
      D => ui_in,
      C => s122,
      en => s123,
      Q => s124);
  gate2: entity work.DIG_Register_BUS
    generic map (
      Bits => 8)
    port map (
      D => ui_in,
      C => s122,
      en => s125,
      Q => s126);
  s8(7 downto 0) <= s126;
  s8(15 downto 8) <= s124;
  gate3: entity work.singExtend
    port map (
      inst => s8,
      n4S => s4,
      n8SD => s5,
      n4D => s6);
  s9 <= s8(3 downto 0);
  s10 <= s8(7 downto 4);
  OPcode <= s8(15 downto 8);
  s97 <= OPcode(6 downto 0);
  imm <= OPcode(7);
  gate4: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 7)
    port map (
      sel => imm,
      in_0 => s97,
      in_1 => "0000000",
      p_out => s98);
  s105 <= s98(0);
  s104 <= s98(1);
  s103 <= s98(2);
  s102 <= s98(3);
  s101 <= s98(4);
  s100 <= s98(5);
  s99 <= s98(6);
  gate5: entity work.controllogic
    port map (
      A => s99,
      B => s100,
      C => s101,
      D => s102,
      E => s103,
      F => s104,
      G => s105,
      muxb0 => s106,
      muxb1 => s107,
      muxb2 => s108,
      src2D => src2D,
      aluop0 => s109,
      aluop1 => s110,
      aluop2 => s111,
      aluop3 => s112,
      aluop4 => s113,
      WE => WE,
      sf => sf,
      alu2D => alu2D,
      iem0 => s114,
      iem1 => s115,
      br0 => s116,
      br1 => s117,
      br2 => s118,
      muxA => muxA,
      ld => ld,
      st => st,
      p_abs => p_abs,
      ioW => ioW,
      ioR => ioR,
      stPC => stPC,
      Reti => Reti,
      randomSel => RandomNUMSel,
      timerSel => timer_Sel);
  WDmux(0) <= (stPC OR ld OR RandomNUMSel);
  WDmux(1) <= (ioR OR stPC);
  WDmux(2) <= (timer_Sel OR RandomNUMSel);
  muxB(0) <= s108;
  muxB(1) <= s107;
  muxB(2) <= s106;
  aluOp(0) <= s113;
  aluOp(1) <= s112;
  aluOp(2) <= s111;
  aluOp(3) <= s110;
  aluOp(4) <= s109;
  br(0) <= s118;
  br(1) <= s117;
  br(2) <= s116;
  iem(0) <= s115;
  iem(1) <= s114;
  gate6: entity work.ImReg
    port map (
      en => imm,
      iem => iem,
      C => s12,
      inst => s8,
      imm => s3);
  s18 <= br(1 downto 0);
  sel <= aluOp(3 downto 0);
  gate7: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => muxA,
      in_0 => s0,
      in_1 => s1,
      p_out => s2);
  gate8: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel => muxB,
      in_0 => s1,
      in_1 => "0000000000000000",
      in_2 => s3,
      in_3 => "0000000000000000",
      in_4 => "0000000000000000",
      in_5 => s4,
      in_6 => s5,
      in_7 => s6,
      p_out => s7);
  gate9: entity work.DIG_RAMDualPort -- mem
    generic map (
      Bits => 16,
      AddrBits => 5)
    port map (
      A => s11,
      Din => s1,
      str => st,
      C => s12,
      ld => ld,
      D => s13);
  gate10: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel => WDmux,
      in_0 => s14,
      in_1 => s15,
      in_2 => Din,
      in_3 => s16,
      in_4 => timer_in,
      in_5 => RandomNUM,
      in_6 => "0000000000000000",
      in_7 => "0000000000000000",
      p_out => s17);
  gate11: entity work.MUX_GATE_2
    port map (
      sel => s18,
      in_0 => '0',
      in_1 => s19,
      in_2 => s20,
      in_3 => s21,
      p_out => s22);
  s23 <= (s22 XOR br(2));
  gate12: entity work.DIG_Register -- Carry
    port map (
      D => s24,
      C => s12,
      en => sf,
      Q => s19);
  gate13: entity work.DIG_Register -- Zero
    port map (
      D => s25,
      C => s12,
      en => sf,
      Q => s20);
  gate14: entity work.DIG_Register -- Neg
    port map (
      D => s26,
      C => s12,
      en => sf,
      Q => s21);
  gate15: entity work.RegisterBlock
    port map (
      DataIn => s17,
      WE => WE,
      clk => s12,
      src => s9,
      Dest => s10,
      RDest => s0,
      Rsrc => s1);
  gate16: entity work.DIG_Register_BUS -- PC
    generic map (
      Bits => 12)
    port map (
      D => s27,
      C => s28,
      en => '1',
      Q => pcOut);
  gate17: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 12)
    port map (
      sel => p_abs,
      in_0 => s31,
      in_1 => s32,
      p_out => s27);
  s34 <= (s33 AND ioW);
  gate18: entity work.DIG_Register_BUS
    generic map (
      Bits => 4)
    port map (
      D => s35,
      C => s12,
      en => s34,
      Q => outputToOutside);
  gate19: entity work.MUX_GATE_BUS_4
    generic map (
      Bits => 16)
    port map (
      sel => sel,
      in_0 => s7,
      in_1 => s36,
      in_2 => s37,
      in_3 => s38,
      in_4 => s39,
      in_5 => s40,
      in_6 => s41,
      in_7 => s42,
      in_8 => s43,
      in_9 => s44,
      in_10 => s45,
      in_11 => s46,
      in_12 => s47,
      in_13 => "0000000000000000",
      in_14 => "0000000000000000",
      in_15 => "0000000000000000",
      p_out => s14);
  gate20: entity work.MUX_GATE_4
    port map (
      sel => sel,
      in_0 => '0',
      in_1 => s48,
      in_2 => s49,
      in_3 => '0',
      in_4 => '0',
      in_5 => '0',
      in_6 => '0',
      in_7 => '0',
      in_8 => s50,
      in_9 => s51,
      in_10 => s52,
      in_11 => '0',
      in_12 => '0',
      in_13 => '0',
      in_14 => '0',
      in_15 => '0',
      p_out => s24);
  s53 <= (aluOp(4) AND s19);
  gate21: entity work.DIG_Register_BUS -- seed
    generic map (
      Bits => 16)
    port map (
      D => s1,
      C => s12,
      en => s58,
      Q => s59);
  s58 <= (s61 AND ioW);
  gate22: entity work.DIG_JK_FF
    generic map (
      Default => '0')
    port map (
      J => s62,
      C => s12,
      K => s62,
      Q => s56);
  gate23: entity work.DIG_D_FF_AS
    port map (
      Set => s64,
      D => s65,
      C => s12,
      Clr => s63,
      Q => s66);
  gate24: entity work.DIG_D_FF_AS
    port map (
      Set => s67,
      D => s66,
      C => s12,
      Clr => s63,
      Q => s68);
  gate25: entity work.DIG_D_FF_AS
    port map (
      Set => s69,
      D => s68,
      C => s12,
      Clr => s63,
      Q => s70);
  gate26: entity work.DIG_D_FF_AS
    port map (
      Set => s71,
      D => s70,
      C => s12,
      Clr => s63,
      Q => s72);
  gate27: entity work.DIG_D_FF_AS
    port map (
      Set => s73,
      D => s72,
      C => s12,
      Clr => s63,
      Q => s74);
  gate28: entity work.DIG_D_FF_AS
    port map (
      Set => s75,
      D => s74,
      C => s12,
      Clr => s63,
      Q => s76);
  gate29: entity work.DIG_D_FF_AS
    port map (
      Set => s77,
      D => s76,
      C => s12,
      Clr => s63,
      Q => s78);
  gate30: entity work.DIG_D_FF_AS
    port map (
      Set => s79,
      D => s78,
      C => s12,
      Clr => s63,
      Q => s80);
  gate31: entity work.DIG_D_FF_AS
    port map (
      Set => s81,
      D => s80,
      C => s12,
      Clr => s63,
      Q => s82);
  gate32: entity work.DIG_D_FF_AS
    port map (
      Set => s83,
      D => s82,
      C => s12,
      Clr => s63,
      Q => s84);
  gate33: entity work.DIG_D_FF_AS
    port map (
      Set => s85,
      D => s84,
      C => s12,
      Clr => s63,
      Q => s86);
  gate34: entity work.DIG_D_FF_AS
    port map (
      Set => s87,
      D => s86,
      C => s12,
      Clr => s63,
      Q => s88);
  gate35: entity work.DIG_D_FF_AS
    port map (
      Set => s89,
      D => s88,
      C => s12,
      Clr => s63,
      Q => s90);
  gate36: entity work.DIG_D_FF_AS
    port map (
      Set => s91,
      D => s90,
      C => s12,
      Clr => s63,
      Q => s92);
  gate37: entity work.DIG_D_FF_AS
    port map (
      Set => s93,
      D => s92,
      C => s12,
      Clr => s63,
      Q => s94);
  gate38: entity work.DIG_D_FF_AS
    port map (
      Set => s95,
      D => s94,
      C => s12,
      Clr => s63,
      Q => s96);
  s55 <= (s12 AND s58);
  s120 <= (s119 AND ioW);
  gate39: entity work.DIG_Register_BUS
    generic map (
      Bits => 4)
    port map (
      D => s121,
      C => s12,
      en => s120,
      Q => outputToOutsideEnable);
  s132 <= (s131 AND ioW);
  gate40: entity work.DIG_Register_BUS -- prescaler
    generic map (
      Bits => 3)
    port map (
      D => s133,
      C => s12,
      en => s132,
      Q => s134);
  s136 <= (s135 AND ioW);
  gate41: entity work.DIG_Register -- timer_is_active
    port map (
      D => s137,
      C => s12,
      en => s136,
      Q => s138);
  gate42: entity work.DIG_JK_FF
    generic map (
      Default => '0')
    port map (
      J => s140,
      C => s12,
      K => '1',
      Q => s141);
  s140 <= (s1(0) AND (s139 AND ioW));
  gate43: entity work.DIG_Counter
    generic map (
      Bits => 8)
    port map (
      en => s138,
      C => s12,
      clr => s141,
      p_out => s142);
  gate44: entity work.DIG_RAMDualPort -- mem
    generic map (
      Bits => 16,
      AddrBits => 3)
    port map (
      A => s152,
      Din => s1,
      str => s153,
      C => s12,
      ld => s154,
      D => s155);
  s153 <= (s156 AND st);
  s154 <= (s156 AND ld);
  FlagOut(0) <= s19;
  FlagOut(1) <= s20;
  FlagOut(2) <= s21;
  FlagOut(15 downto 3) <= "0000000000000";
  gate45: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000000101",
      eq => s33);
  s38 <= (s2 AND s7);
  s39 <= (s2 OR s7);
  s40 <= (s2 XOR s7);
  gate46: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000000000",
      eq => s25);
  gate47: entity work.LSL
    port map (
      Di => s2,
      Ci => s53,
      Do => s43,
      Co => s50);
  gate48: entity work.LSR
    port map (
      Di => s2,
      Ci => s53,
      Do => s44,
      Co => s51);
  gate49: entity work.ASR
    port map (
      Di => s2,
      C => s52,
      Do => s45);
  gate50: entity work.SWAP
    port map (
      Di => s2,
      Do => s46);
  gate51: entity work.SWAPN
    port map (
      Di => s2,
      Do => s47);
  s41 <= NOT s2;
  gate52: entity work.DIG_Neg
    generic map (
      Bits => 16)
    port map (
      p_in => s2,
      p_out => s42);
  gate53: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s58,
      in_0 => "0000000000000000",
      in_1 => s59,
      p_out => s60);
  gate54: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000001000",
      eq => s61);
  s65 <= (s76 XOR (s86 XOR (s90 XOR s94)));
  RandomNUM(0) <= s66;
  RandomNUM(1) <= s68;
  RandomNUM(2) <= s70;
  RandomNUM(3) <= s72;
  RandomNUM(4) <= s74;
  RandomNUM(5) <= s76;
  RandomNUM(6) <= s78;
  RandomNUM(7) <= s80;
  RandomNUM(8) <= s82;
  RandomNUM(9) <= s84;
  RandomNUM(10) <= s86;
  RandomNUM(11) <= s88;
  RandomNUM(12) <= s90;
  RandomNUM(13) <= s92;
  RandomNUM(14) <= s94;
  RandomNUM(15) <= s96;
  gate55: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000000110",
      eq => s119);
  uio_out(3 downto 0) <= pcOut(11 downto 8);
  uio_out(7 downto 4) <= outputToOutside;
  uio_oe(3 downto 0) <= "0000";
  uio_oe(7 downto 4) <= outputToOutsideEnable;
  gate56: entity work.DIG_Add
    generic map (
      Bits => 16)
    port map (
      a => s2,
      b => s7,
      c_i => s53,
      s => s36,
      c_o => s48);
  gate57: entity work.DIG_Sub
    generic map (
      Bits => 16)
    port map (
      a => s2,
      b => s7,
      c_i => s53,
      s => s37,
      c_o => s49);
  gate58: entity work.DIG_Add
    generic map (
      Bits => 12)
    port map (
      a => pcOut,
      b => "000000000001",
      c_i => '0',
      s => s29);
  gate59: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000000001",
      eq => s131);
  gate60: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000000010",
      eq => s135);
  gate61: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => s14,
      b => "0000000000000011",
      eq => s139);
  s11 <= s14(4 downto 0);
  s35 <= s1(3 downto 0);
  s26 <= s14(15);
  s32 <= s14(11 downto 0);
  s121 <= s1(3 downto 0);
  uo_out <= pcOut(7 downto 0);
  s133 <= s1(2 downto 0);
  s137 <= s1(0);
  s143 <= s142(0);
  s144 <= s142(1);
  s145 <= s142(2);
  s146 <= s142(3);
  s147 <= s142(4);
  s148 <= s142(5);
  s149 <= s142(6);
  s150 <= s142(7);
  s152 <= s14(2 downto 0);
  s156 <= s14(5);
  s16(11 downto 0) <= s29;
  s16(15 downto 12) <= "0000";
  gate62: entity work.DIG_Add
    generic map (
      Bits => 12)
    port map (
      a => s29,
      b => s32,
      c_i => '0',
      s => s30);
  gate63: entity work.MUX_GATE_3
    port map (
      sel => s134,
      in_0 => s143,
      in_1 => s144,
      in_2 => s145,
      in_3 => s146,
      in_4 => s147,
      in_5 => s148,
      in_6 => s149,
      in_7 => s150,
      p_out => s151);
  gate64: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s156,
      in_0 => s13,
      in_1 => s155,
      p_out => s15);
  s64 <= s60(0);
  s67 <= s60(1);
  s69 <= s60(2);
  s71 <= s60(3);
  s73 <= s60(4);
  s75 <= s60(5);
  s77 <= s60(6);
  s79 <= s60(7);
  s81 <= s60(8);
  s83 <= s60(9);
  s85 <= s60(10);
  s87 <= s60(11);
  s89 <= s60(12);
  s91 <= s60(13);
  s93 <= s60(14);
  s95 <= s60(15);
  gate65: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 12)
    port map (
      sel => s23,
      in_0 => s29,
      in_1 => s30,
      p_out => s31);
  gate66: entity work.DIG_Counter
    generic map (
      Bits => 16)
    port map (
      en => s138,
      C => s151,
      clr => s141,
      p_out => timer_in);
  gate67: entity work.DIG_D_FF_AS
    port map (
      Set => '0',
      D => s54,
      C => s55,
      Clr => s56,
      Q => s57,
      notQ => s54);
  s62 <= (s57 OR s56);
  s63 <= (s58 AND NOT s62);
end Behavioral;
