/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Driver
(
    input in,
    input sel,
    output out
);
    assign out = (sel == 1'b1)? in : 1'bz;
endmodule

module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_4x1
(
    input [1:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    output reg out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


// Register for storing large constants.
// There is a 1-bit command describing this register. 
// In this way, 15 bits can be stored (the 16th bit 
// activates the writing of this register and therefore 
// is always one). The 16th bit will be set according 
// to the 'immediate extend mode' (iem).
module ImReg (
  input en, // enables storage
  input [1:0] iem, // immediate extend mode (0: sign extend; 1: extend with 0, 2:extend with S0, 3:extend with D0)
  input C,
  input [15:0] inst, // the current instruction
  output [15:0] imm // The constant of register contents and bit 8.

);
  wire [14:0] s0;
  wire [14:0] s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  assign s2 = inst[0];
  assign s3 = inst[4];
  assign s0 = inst[14:0];
  // imm
  DIG_Register_BUS #(
    .Bits(15)
  )
  DIG_Register_BUS_i0 (
    .D( s0 ),
    .C( C ),
    .en( en ),
    .Q( s1 )
  );
  assign s5 = s1[14];
  Mux_4x1 Mux_4x1_i1 (
    .sel( iem ),
    .in_0( s5 ),
    .in_1( 1'b0 ),
    .in_2( s2 ),
    .in_3( s3 ),
    .out( s4 )
  );
  assign imm[14:0] = s1;
  assign imm[15] = s4;
endmodule
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module DIG_JK_FF
#(
    parameter Default = 1'b0
)
(
   input J,
   input C,
   input K,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        if (~J & K)
            state <= 1'b0;
         else if (J & ~K)
            state <= 1'b1;
         else if (J & K)
            state <= ~state;
    end

    initial begin
        state = Default;
    end
endmodule


module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Mux_8x1
(
    input [2:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    input in_4,
    input in_5,
    input in_6,
    input in_7,
    output reg out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_CounterPreset #(
    parameter Bits = 2,
    parameter maxValue = 4
)
(
    input C,
    input en,
    input clr,
    input dir,
    input [(Bits-1):0] in,
    input ld,
    output [(Bits-1):0] out,
    output ovf
);

    reg [(Bits-1):0] count = 'h0;

    function [(Bits-1):0] maxVal (input [(Bits-1):0] maxv);
        if (maxv == 0)
            maxVal = (1 << Bits) - 1;
        else
            maxVal = maxv;
    endfunction

    assign out = count;
    assign ovf = ((count == maxVal(maxValue) & dir == 1'b0)
                  | (count == 'b0 & dir == 1'b1))? en : 1'b0;

    always @ (posedge C) begin
        if (clr == 1'b1)
            count <= 'h0;
        else if (ld == 1'b1)
            count <= in;
        else if (en == 1'b1) begin
            if (dir == 1'b0) begin
                if (count == maxVal(maxValue))
                    count <= 'h0;
                else
                    count <= count + 1'b1;
            end
            else begin
                if (count == 'h0)
                    count <= maxVal(maxValue);
                else
                    count <= count - 1;
            end
        end
    end
endmodule


module DriverBus#(
    parameter Bits = 2
)
(
    input [(Bits-1):0] in,
    input sel,
    output [(Bits-1):0] out
);
    assign out = (sel == 1'b1)? in : {Bits{1'bz}};
endmodule

module timer (
  input [15:0] dOut,
  input [15:0] Addr,
  input ioW,
  input ioR,
  input C,
  input InterLock,
  input [15:0] timerConfigAddr,
  input [15:0] timerTargetAddr,
  input [15:0] timerResetAddr,
  input [15:0] timerReadAddr,
  input rst,
  output outEn,
  output [15:0] TimerOut,
  output \timer?nterrupt 
);
  wire s0;
  wire s1;
  wire s2;
  wire timer_en;
  wire [6:0] s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire [2:0] s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire [15:0] s16;
  wire [15:0] s17;
  wire [15:0] s18;
  wire s19;
  wire s20;
  wire s21;
  wire s22;
  wire s23;
  wire s24;
  wire [2:0] timerPrescaler;
  wire s25;
  wire outEn_temp;
  wire s26;
  wire s27;
  wire [15:0] s28;
  wire s29;
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i0 (
    .a( Addr ),
    .b( timerResetAddr ),
    .\= ( s0 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i1 (
    .a( Addr ),
    .b( timerTargetAddr ),
    .\= ( s13 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i2 (
    .a( timerReadAddr ),
    .b( Addr ),
    .\= ( s26 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i3 (
    .a( Addr ),
    .b( timerConfigAddr ),
    .\= ( s29 )
  );
  assign s15 = ~ C;
  assign s1 = (dOut[0] & (s0 & ioW));
  assign s14 = (s13 & ioW);
  assign outEn_temp = (s26 & ioR);
  assign s27 = (s29 & ioW);
  // Reset
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i4 (
    .J( s1 ),
    .C( C ),
    .K( 1'b1 ),
    .Q( s2 )
  );
  // target
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( dOut ),
    .C( s15 ),
    .en( s14 ),
    .Q( s16 )
  );
  // Config
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i6 (
    .D( dOut ),
    .C( s15 ),
    .en( s27 ),
    .Q( s28 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i7 (
    .a( s16 ),
    .b( 16'b0 ),
    .\> ( s20 ),
    .\= ( s21 )
  );
  assign timer_en = s28[0];
  assign timerPrescaler = s28[3:1];
  DIG_Counter_Nbit #(
    .Bits(7)
  )
  DIG_Counter_Nbit_i8 (
    .en( timer_en ),
    .C( C ),
    .clr( 1'b0 ),
    .out( s3 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i9 (
    .sel( s20 ),
    .in_0( 16'b0 ),
    .in_1( s16 ),
    .out( s17 )
  );
  assign s4 = s3[0];
  assign s5 = s3[1];
  assign s6 = s3[2];
  assign s7 = s3[3];
  assign s8 = s3[4];
  assign s9 = s3[5];
  assign s10 = s3[6];
  Mux_8x1 Mux_8x1_i10 (
    .sel( s11 ),
    .in_0( C ),
    .in_1( s4 ),
    .in_2( s5 ),
    .in_3( s6 ),
    .in_4( s7 ),
    .in_5( s8 ),
    .in_6( s9 ),
    .in_7( s10 ),
    .out( s12 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i11 (
    .a( s17 ),
    .b( s18 ),
    .\= ( s19 )
  );
  assign \timer?nterrupt  = (~ InterLock & (~ s21 & s19));
  assign s22 = (~ s21 & ((s19 & s28[4]) | s2));
  DIG_CounterPreset #(
    .Bits(16),
    .maxValue(0)
  )
  DIG_CounterPreset_i12 (
    .en( timer_en ),
    .C( s23 ),
    .dir( 1'b0 ),
    .in( 16'b0 ),
    .ld( s24 ),
    .clr( 1'b0 ),
    .out( s18 )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i13 (
    .sel( s22 ),
    .in_0( timerPrescaler ),
    .in_1( 3'b0 ),
    .out( s11 )
  );
  assign s25 = (InterLock | ((s19 & ~ s21) & ~ s22));
  DriverBus #(
    .Bits(16)
  )
  DriverBus_i14 (
    .in( s18 ),
    .sel( outEn_temp ),
    .out( TimerOut )
  );
  assign s24 = (s22 | rst);
  Mux_2x1 Mux_2x1_i15 (
    .sel( s25 ),
    .in_0( s12 ),
    .in_1( 1'b1 ),
    .out( s23 )
  );
  assign outEn = outEn_temp;
endmodule

module OpCode
  (
    input clk,
    input rst,
    input instructionInput ,
    input [15:0]ProgramCounter,
    output reg [15:0] opcoder,
    output PcClock,
    output PcShifter
  );

  reg[15:0] instructionRegister=15'h0;
  reg[5:0] CounterRegister=5'h0;
  reg pcClockHold=1'h0;
  reg pcwireshifter;
  reg [4:0] shiftIndex=5'h10;

  reg state=1'b0;
  reg clockon= 1'b0;
  assign PcClock =pcClockHold;
  assign PcShifter=pcwireshifter;

  always @( posedge clk)
  begin
    if(pcClockHold ==0)
    begin
      if (rst)
      begin
        pcClockHold<=1;
        instructionRegister<= 15'h0;
        CounterRegister<= 5'h0;
        shiftIndex<= 5'h10;
        opcoder<=15'h0;
        state<=1'b0;
        clockon<=0;
        pcwireshifter<=0;
      end
      else
      begin
        if(clockon)
        begin
          pcClockHold<=1;
          clockon<=0;
        end
        else
        begin
          if(state)
          begin

            pcwireshifter<= 0;
            instructionRegister <= (instructionRegister >> 1) | instructionInput<<15;
            CounterRegister <= CounterRegister + 1;
            if(CounterRegister == 5'h10)
            begin
              opcoder<=instructionRegister;
              CounterRegister<=5'h0;
              clockon<= 1;
              state<=1'b0;
              instructionRegister<=15'h0;
            end
          end
          else
          begin
            pcwireshifter<=  ProgramCounter [shiftIndex-1] ;
            shiftIndex<=shiftIndex-1;
            if(shiftIndex==5'h1)
            begin
              shiftIndex<=5'h10;
              state<=1'b1;
            end
          end

        end
      end

    end
    else
    begin
      opcoder<=15'h0;
      pcClockHold<=0;
    end
  end




endmodule

module Register1
  (
    input D,
    input C,
    input en,
    input rst,
    output Q
  );

  reg  state = 'h0;

  assign Q = state;

  always @ (negedge C)
  begin

    if(rst)
    begin
      state <= 1'h0;
    end
    if (en)
      state <= D;

  end
endmodule


module register_1bit (
  input D,
  input C,
  input en,
  input rst,
  output Q
);
  // Register1
  Register1 Register1_i0 (
    .D( D ),
    .C( C ),
    .en( en ),
    .rst( rst ),
    .Q( Q )
  );
endmodule
module Register8
  (
    input [7:0]D,
    input C,
    input en,
    input rst,
    output [7:0]Q
  );

  reg [7:0] state = 'h0;

  assign Q = state;

  always @ (posedge C)
  begin
    if(rst)
    begin
      state <= 8'h0;
    end
    if (en)
      state <= D;


  end
endmodule


module register_8bit (
  input [7:0] D,
  input C,
  input en,
  input rst,
  output [7:0] Q
);
  // Register8
  Register8 Register8_i0 (
    .D( D ),
    .C( C ),
    .en( en ),
    .rst( rst ),
    .Q( Q )
  );
endmodule

module programCounter
  (
    input [15:0] AluIn,
    input clk,
    input rst,
    input absJmp,
    input intr,
    input reti,
    input relJmp,
    output [15:0] Nextpc,
    output [15:0] PC
  );
  reg[15:0] interuptFuncAdr = 16'h2;
  reg[15:0] interruptAdress = 16'b0000000000000000;

  reg[15:0] PCr = 16'b0000000000000000;
  reg [15:0] Nextpcr = 16'b0000000000000001;
  reg isStarted = 1'b0;
  assign Nextpc = Nextpcr;
  assign PC = PCr;




  always @( posedge clk)
  begin

    if(!isStarted)
    begin
      PCr <= 16'b0000000000000000;
      Nextpcr<=  16'b0000000000000001;
      isStarted <= 1'b1;
    end
    else
      if(rst)
      begin
        PCr <= 16'b0000000000000000;
        Nextpcr<=  16'b0000000000000001;
      end
      else
      begin
        if(reti)
        begin
          PCr <= interruptAdress+1;
          Nextpcr <=interruptAdress+2;
        end
        else if(intr)
        begin
          if( relJmp || absJmp)
          begin
            interruptAdress <= PCr-1;
          end
          else
          begin
            interruptAdress <=PCr;
          end
          PCr <= interuptFuncAdr;
          Nextpcr <=interuptFuncAdr+1;
        end
        else if(relJmp)
        begin
          PCr <= PCr + AluIn+1;
          Nextpcr <=Nextpcr+AluIn+1;
        end
        else if(absJmp)
        begin
          PCr <=AluIn;
          Nextpcr<=AluIn+1;
        end
        else
        begin
          PCr <= PCr + 1;
          Nextpcr <= Nextpcr + 1;
        end
      end

  end




endmodule


module Demux4
#(
    parameter Default = 0 
)
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    output out_8,
    output out_9,
    output out_10,
    output out_11,
    output out_12,
    output out_13,
    output out_14,
    output out_15,
    input [3:0] sel,
    input in
);
    assign out_0 = (sel == 4'h0)? in : Default;
    assign out_1 = (sel == 4'h1)? in : Default;
    assign out_2 = (sel == 4'h2)? in : Default;
    assign out_3 = (sel == 4'h3)? in : Default;
    assign out_4 = (sel == 4'h4)? in : Default;
    assign out_5 = (sel == 4'h5)? in : Default;
    assign out_6 = (sel == 4'h6)? in : Default;
    assign out_7 = (sel == 4'h7)? in : Default;
    assign out_8 = (sel == 4'h8)? in : Default;
    assign out_9 = (sel == 4'h9)? in : Default;
    assign out_10 = (sel == 4'ha)? in : Default;
    assign out_11 = (sel == 4'hb)? in : Default;
    assign out_12 = (sel == 4'hc)? in : Default;
    assign out_13 = (sel == 4'hd)? in : Default;
    assign out_14 = (sel == 4'he)? in : Default;
    assign out_15 = (sel == 4'hf)? in : Default;
endmodule

module Register16
  (
    input [15:0]D,
    input C,
    input en,
    input rst,
    output [15:0]Q
  );

  reg [15:0] state = 'h0;

  assign Q = state;

  always @ (posedge C)
  begin
    if(rst)
    begin
      state <= 16'h0;
    end
    if (en)
      state <= D;
  end
endmodule


module register_16bit (
  input [15:0] D,
  input C,
  input en,
  input rst,
  output [15:0] Q
);
  // Register16
  Register16 Register16_i0 (
    .D( D ),
    .C( C ),
    .en( en ),
    .rst( rst ),
    .Q( Q )
  );
endmodule

module Mux_16x1_NBits #(
    parameter Bits = 2
)
(
    input [3:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    input [(Bits - 1):0] in_8,
    input [(Bits - 1):0] in_9,
    input [(Bits - 1):0] in_10,
    input [(Bits - 1):0] in_11,
    input [(Bits - 1):0] in_12,
    input [(Bits - 1):0] in_13,
    input [(Bits - 1):0] in_14,
    input [(Bits - 1):0] in_15,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            4'h0: out = in_0;
            4'h1: out = in_1;
            4'h2: out = in_2;
            4'h3: out = in_3;
            4'h4: out = in_4;
            4'h5: out = in_5;
            4'h6: out = in_6;
            4'h7: out = in_7;
            4'h8: out = in_8;
            4'h9: out = in_9;
            4'ha: out = in_10;
            4'hb: out = in_11;
            4'hc: out = in_12;
            4'hd: out = in_13;
            4'he: out = in_14;
            4'hf: out = in_15;
            default:
                out = 'h0;
        endcase
    end
endmodule


module RegisterBlock (
  input [15:0] DataIn,
  input WE,
  input clk,
  input [3:0] src,
  input [3:0] Dest,
  input rst,
  output [15:0] RDest,
  output [15:0] Rsrc
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire [15:0] s16;
  wire [15:0] s17;
  wire [15:0] s18;
  wire [15:0] s19;
  wire [15:0] s20;
  wire [15:0] s21;
  wire [15:0] s22;
  wire [15:0] s23;
  wire [15:0] s24;
  wire [15:0] s25;
  wire [15:0] s26;
  wire [15:0] s27;
  wire [15:0] s28;
  wire [15:0] s29;
  wire [15:0] s30;
  wire [15:0] s31;
  Demux4 #(
    .Default(0)
  )
  Demux4_i0 (
    .sel( Dest ),
    .in( WE ),
    .out_0( s0 ),
    .out_1( s1 ),
    .out_2( s2 ),
    .out_3( s3 ),
    .out_4( s4 ),
    .out_5( s5 ),
    .out_6( s6 ),
    .out_7( s7 ),
    .out_8( s8 ),
    .out_9( s9 ),
    .out_10( s10 ),
    .out_11( s11 ),
    .out_12( s12 ),
    .out_13( s13 ),
    .out_14( s14 ),
    .out_15( s15 )
  );
  // R0
  register_16bit register_16bit_i1 (
    .D( DataIn ),
    .C( clk ),
    .en( s0 ),
    .rst( rst ),
    .Q( s16 )
  );
  // R1
  register_16bit register_16bit_i2 (
    .D( DataIn ),
    .C( clk ),
    .en( s1 ),
    .rst( rst ),
    .Q( s17 )
  );
  // R2
  register_16bit register_16bit_i3 (
    .D( DataIn ),
    .C( clk ),
    .en( s2 ),
    .rst( rst ),
    .Q( s18 )
  );
  // R3
  register_16bit register_16bit_i4 (
    .D( DataIn ),
    .C( clk ),
    .en( s3 ),
    .rst( rst ),
    .Q( s19 )
  );
  // R4
  register_16bit register_16bit_i5 (
    .D( DataIn ),
    .C( clk ),
    .en( s4 ),
    .rst( rst ),
    .Q( s20 )
  );
  // R5
  register_16bit register_16bit_i6 (
    .D( DataIn ),
    .C( clk ),
    .en( s5 ),
    .rst( rst ),
    .Q( s21 )
  );
  // R6
  register_16bit register_16bit_i7 (
    .D( DataIn ),
    .C( clk ),
    .en( s6 ),
    .rst( rst ),
    .Q( s22 )
  );
  // R7
  register_16bit register_16bit_i8 (
    .D( DataIn ),
    .C( clk ),
    .en( s7 ),
    .rst( rst ),
    .Q( s23 )
  );
  // R8
  register_16bit register_16bit_i9 (
    .D( DataIn ),
    .C( clk ),
    .en( s8 ),
    .rst( rst ),
    .Q( s24 )
  );
  // R9
  register_16bit register_16bit_i10 (
    .D( DataIn ),
    .C( clk ),
    .en( s9 ),
    .rst( rst ),
    .Q( s25 )
  );
  // R10
  register_16bit register_16bit_i11 (
    .D( DataIn ),
    .C( clk ),
    .en( s10 ),
    .rst( rst ),
    .Q( s26 )
  );
  // R11
  register_16bit register_16bit_i12 (
    .D( DataIn ),
    .C( clk ),
    .en( s11 ),
    .rst( rst ),
    .Q( s27 )
  );
  // R12
  register_16bit register_16bit_i13 (
    .D( DataIn ),
    .C( clk ),
    .en( s12 ),
    .rst( rst ),
    .Q( s28 )
  );
  // BranchPointer
  register_16bit register_16bit_i14 (
    .D( DataIn ),
    .C( clk ),
    .en( s13 ),
    .rst( rst ),
    .Q( s29 )
  );
  // StackPointer
  register_16bit register_16bit_i15 (
    .D( DataIn ),
    .C( clk ),
    .en( s14 ),
    .rst( rst ),
    .Q( s30 )
  );
  // ReturnAddr
  register_16bit register_16bit_i16 (
    .D( DataIn ),
    .C( clk ),
    .en( s15 ),
    .rst( rst ),
    .Q( s31 )
  );
  Mux_16x1_NBits #(
    .Bits(16)
  )
  Mux_16x1_NBits_i17 (
    .sel( Dest ),
    .in_0( s16 ),
    .in_1( s17 ),
    .in_2( s18 ),
    .in_3( s19 ),
    .in_4( s20 ),
    .in_5( s21 ),
    .in_6( s22 ),
    .in_7( s23 ),
    .in_8( s24 ),
    .in_9( s25 ),
    .in_10( s26 ),
    .in_11( s27 ),
    .in_12( s28 ),
    .in_13( s29 ),
    .in_14( s30 ),
    .in_15( s31 ),
    .out( RDest )
  );
  Mux_16x1_NBits #(
    .Bits(16)
  )
  Mux_16x1_NBits_i18 (
    .sel( src ),
    .in_0( s16 ),
    .in_1( s17 ),
    .in_2( s18 ),
    .in_3( s19 ),
    .in_4( s20 ),
    .in_5( s21 ),
    .in_6( s22 ),
    .in_7( s23 ),
    .in_8( s24 ),
    .in_9( s25 ),
    .in_10( s26 ),
    .in_11( s27 ),
    .in_12( s28 ),
    .in_13( s29 ),
    .in_14( s30 ),
    .in_15( s31 ),
    .out( Rsrc )
  );
endmodule
module DIG_ROM_65536X16_pgr (
    input [15:0] A,
    input sel,
    output reg [15:0] D
);
    reg [15:0] my_rom [0:16];

    always @ (*) begin
        if (~sel)
            D = 16'hz;
        else if (A > 16'h10)
            D = 16'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 16'h3d03;
        my_rom[1] = 16'h0;
        my_rom[2] = 16'h3d00;
        my_rom[3] = 16'h4400;
        my_rom[4] = 16'ha0f;
        my_rom[5] = 16'ha10;
        my_rom[6] = 16'hc11;
        my_rom[7] = 16'h3fb1;
        my_rom[8] = 16'h1201;
        my_rom[9] = 16'h39fc;
        my_rom[10] = 16'h9214;
        my_rom[11] = 16'h9c0;
        my_rom[12] = 16'h3fdc;
        my_rom[13] = 16'h4700;
        my_rom[14] = 16'h3fb0;
        my_rom[15] = 16'h3dfa;
        my_rom[16] = 16'h3dff;
    end
endmodule


module singExtend (
  input [15:0] inst, // instruction word
  output [15:0] \4S , // The four bits taken from Rs.
  output [15:0] \8SD , // The eight bits taken from Rs,Rd with sign extension.
  output [15:0] \4D  // The four bits taken from Rd.

);
  wire s0;
  assign \4D [3:0] = inst[7:4];
  assign \4D [15:4] = 12'b0;
  assign \4S [3:0] = inst[3:0];
  assign \4S [15:4] = 12'b0;
  assign s0 = inst[7];
  assign \8SD [6:0] = inst[6:0];
  assign \8SD [7] = s0;
  assign \8SD [8] = s0;
  assign \8SD [9] = s0;
  assign \8SD [10] = s0;
  assign \8SD [11] = s0;
  assign \8SD [12] = s0;
  assign \8SD [13] = s0;
  assign \8SD [14] = s0;
  assign \8SD [15] = s0;
endmodule

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module controllogic (
  input A,
  input B,
  input C,
  input D,
  input E,
  input F,
  input G,
  output muxb0,
  output muxb1,
  output muxb2,
  output aluop0,
  output aluop1,
  output aluop2,
  output aluop3,
  output aluop4,
  output WE,
  output sf,
  output iem0,
  output iem1,
  output br0,
  output br1,
  output br2,
  output muxA,
  output ld,
  output st,
  output abs,
  output ioW,
  output ioR,
  output stPC,
  output Reti,
  output randomSel,
  output timerSel,
  output \read-flags ,
  output storeFlagI
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  assign s3 = ~ A;
  assign s0 = ~ B;
  assign s1 = ~ C;
  assign s2 = ~ D;
  assign s5 = ~ E;
  assign s6 = ~ F;
  assign s4 = ~ G;
  assign muxb0 = ((A & s0 & s1 & s2 & E & F & G) | (s3 & s1 & D & E & F & s4) | (s3 & B & C & s5 & s6 & s4) | (A & s0 & s1 & s5 & F & s4) | (s3 & s0 & s1 & D & E & s4) | (s3 & s0 & C & s2 & s5 & s4) | (s3 & B & s1 & s2 & s5 & G) | (A & s0 & s1 & D & s5 & s6) | (s3 & C & D & s6 & G) | (s3 & C & s2 & E & G) | (s3 & B & C & E & G) | (s3 & B & C & s2 & E) | (s0 & s1 & D & s5 & F & s4));
  assign muxb1 = ((A & s0 & s1 & s2 & E & F & s4) | (A & s0 & s1 & D & s5 & F & s4) | (s3 & C & s2 & s5 & s6 & G) | (s3 & B & s1 & s2 & s5 & s4) | (A & s0 & s1 & s2 & s5 & G) | (A & s0 & s1 & s2 & s5 & s6) | (s3 & s1 & D & F & G) | (s3 & C & D & s6 & s4) | (s3 & B & C & s6 & G) | (s3 & B & C & F & s4) | (s3 & C & s2 & E & s4) | (s3 & s0 & s1 & D & G) | (s3 & B & D & E) | (s3 & B & C & E) | (s0 & s1 & D & s5 & s6 & G));
  assign muxb2 = ((s3 & B & C & D & E & F & G) | (s3 & C & s2 & s5 & s6 & s4) | (s3 & B & s2 & s5 & F & G) | (s3 & B & s1 & s5 & F & G) | (A & s0 & s1 & s5 & s6 & s4) | (s3 & s0 & s1 & D & F & s4) | (s3 & s0 & C & D & s6 & G) | (A & s0 & s1 & s2 & F & G) | (s3 & s0 & C & s2 & s5 & s4) | (s3 & s0 & C & s2 & E & G) | (s3 & B & s1 & s2 & s5 & G) | (A & s0 & s1 & s2 & s5 & s4) | (s3 & s1 & D & E & s4));
  assign aluop0 = ((s3 & s0 & s1 & D & E & F & s4) | (s3 & s0 & C & s2 & s5 & s6 & G) | (s3 & s0 & C & s2 & s5 & F & s4) | (s3 & s0 & C & D & E & F & G) | (s3 & s1 & s2 & s5 & F & G) | (s3 & s0 & s1 & E & s6 & G) | (s3 & B & s1 & s2 & F));
  assign aluop1 = ((s3 & s0 & C & D & s5 & F & G) | (A & s0 & s1 & s2 & E & s6 & G) | (A & s0 & s1 & s2 & E & F & s4) | (s3 & B & s1 & D & s5 & s4) | (s3 & s0 & C & D & E & s6) | (s3 & B & s1 & D & s5 & s6) | (s3 & B & s1 & s2 & E));
  assign aluop2 = ((s3 & B & s1 & D & s5 & F & s4) | (A & s0 & s1 & s2 & E & s6 & G) | (A & s0 & s1 & s2 & E & F & s4) | (s3 & s0 & s2 & E & F & G) | (s3 & s0 & D & s5 & s6 & s4) | (s3 & s0 & C & s5 & F & G) | (s3 & s0 & C & s2 & E & F) | (s3 & s0 & C & D & s6) | (s3 & s0 & C & D & s5));
  assign aluop3 = ((s3 & s0 & D & E & F & G) | (s3 & s0 & C & D & F & s4) | (s3 & s0 & s2 & E & s6) | (s3 & B & s1 & s5 & s6) | (s3 & s0 & C & s2 & s5) | (s3 & B & s1 & s2 & s5) | (s0 & s1 & s2 & E & s6 & G) | (s0 & s1 & s2 & E & F & s4));
  assign aluop4 = ((s3 & B & C & s2 & s5 & s6 & G) | (s3 & B & C & s2 & s5 & F & s4) | (A & s0 & s1 & s2 & s5 & s6 & s4) | (s3 & s1 & D & E & s6 & s4) | (s3 & s0 & s1 & E & F & s4) | (s3 & s0 & s1 & s2 & F & s4) | (s3 & s0 & C & D & s5 & G) | (s3 & B & s1 & s2 & E & G) | (s3 & B & s1 & D & s5 & G) | (s3 & s0 & s5 & F & G) | (s3 & s0 & D & s6 & s4) | (s3 & s0 & D & E & s6) | (s3 & s0 & C & E & s6) | (s0 & s1 & s2 & s5 & F & G));
  assign WE = ((s3 & D & s5 & F & s4) | (s3 & s1 & E & s6 & s4) | (s3 & s1 & E & F & G) | (s3 & C & s2 & s5 & s4) | (s3 & s1 & D & s5 & s6) | (s3 & C & s2 & s5 & F) | (s3 & s0 & D & s6) | (s3 & s1 & s2 & E) | (s3 & s0 & D & s5) | (s3 & s0 & s1 & D) | (s3 & s0 & C & s2) | (s0 & s1 & D & s5 & s6) | (s0 & s1 & s2 & G) | (s0 & s1 & s2 & F));
  assign sf = ((A & s0 & s1 & D & s5 & F & s4) | (s3 & s1 & D & s5 & s6 & s4) | (s3 & s0 & s2 & F & s4) | (s3 & s0 & D & F & G) | (s3 & s0 & s1 & F & G) | (s3 & s0 & C & s6) | (s3 & B & s1 & s2) | (s3 & s0 & E) | (s0 & s1 & s2 & E & s6 & G) | (s0 & s1 & s2 & E & F & s4));
  assign iem0 = ((s3 & s0 & C & s2 & s5 & s6 & G) | (A & s0 & s1 & s2 & s5 & s6 & G) | (A & s0 & s1 & s2 & E & F & s4) | (s3 & C & D & E & s6 & s4) | (s3 & s0 & C & D & s6 & s4) | (s3 & B & C & D & F & s4) | (s3 & s0 & C & s2 & E & s4) | (s3 & B & s1 & s2 & s5 & s4) | (s3 & s1 & D & E & G) | (s3 & s0 & s1 & D & G));
  assign iem1 = ((s3 & B & s1 & D & E & s6 & G) | (s3 & B & C & D & E & F & s4));
  assign br0 = ((s3 & B & C & s2 & E & F & G) | (s3 & B & C & D & s6 & G) | (s3 & B & C & D & s5 & s6));
  assign br1 = ((s3 & B & C & s2 & E & s6 & G) | (s3 & B & C & s2 & E & F & s4) | (s3 & B & C & D & s5 & s6));
  assign br2 = ((s3 & B & C & D & s5 & s6 & G) | (s3 & B & C & s2 & E & s4) | (s3 & B & C & s2 & E & F));
  assign muxA = ((s3 & B & s1 & D & E & s6 & s4) | (s3 & B & C & s2 & s5 & F & s4) | (A & s0 & s1 & s2 & s5 & G) | (A & s0 & s1 & s2 & s5 & F));
  assign ld = ((s3 & B & s1 & D & E & s6 & s4) | (s3 & B & s1 & D & E & F & G) | (s3 & B & C & s2 & s5 & s4));
  assign st = ((s3 & B & s1 & D & s5 & F & G) | (s3 & B & s1 & D & E & s6 & G) | (s3 & B & s1 & D & E & F & s4) | (s3 & B & C & s2 & s5 & s6 & G));
  assign abs = ((s3 & B & C & D & E & s6 & s4) | (A & s0 & s1 & s2 & E & s6 & s4) | (s3 & B & C & D & s5 & F));
  assign ioW = ((A & s0 & s1 & s2 & s5 & s6 & s4) | (s3 & B & C & D & E & F));
  assign ioR = ((A & s0 & s1 & D & s5 & s6 & s4) | (A & s0 & s1 & s2 & s5 & G) | (A & s0 & s1 & s2 & s5 & F));
  assign stPC = (s3 & B & C & D & s5 & F & s4);
  assign Reti = (A & s0 & s1 & s2 & E & s6 & s4);
  assign randomSel = (A & s0 & s1 & s2 & E & F & G);
  assign timerSel = (A & s0 & s1 & D & s5 & s6 & s4);
  assign \read-flags  = (A & s0 & s1 & D & s5 & s6 & G);
  assign storeFlagI = (A & s0 & s1 & D & s5 & F & s4);
endmodule

module DIG_Neg #(
    parameter Bits = 1
)
(
      input signed [(Bits-1):0] in,
      output signed [(Bits-1):0] out
);
    assign out = -in;
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module DIG_Mul_unsigned #(
    parameter Bits = 1
)
(
    
      input [(Bits-1):0] a,
      input [(Bits-1):0] b,
      output [(Bits*2-1):0] mul
    
);
    assign mul = a * b;
endmodule


module Mux_16x1
(
    input [3:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    input in_4,
    input in_5,
    input in_6,
    input in_7,
    input in_8,
    input in_9,
    input in_10,
    input in_11,
    input in_12,
    input in_13,
    input in_14,
    input in_15,
    output reg out
);
    always @ (*) begin
        case (sel)
            4'h0: out = in_0;
            4'h1: out = in_1;
            4'h2: out = in_2;
            4'h3: out = in_3;
            4'h4: out = in_4;
            4'h5: out = in_5;
            4'h6: out = in_6;
            4'h7: out = in_7;
            4'h8: out = in_8;
            4'h9: out = in_9;
            4'ha: out = in_10;
            4'hb: out = in_11;
            4'hc: out = in_12;
            4'hd: out = in_13;
            4'he: out = in_14;
            4'hf: out = in_15;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module tt_um_smallcpu (
  input clk,
  input rst_n,
  input [7:0] ui_in,
  input [7:0] uio_in,
  input ena,
  output [7:0] uo_out,
  output [7:0] uio_out,
  output [7:0] uio_oe
);
  wire muxA;
  wire [15:0] s0;
  wire [15:0] DataOut;
  wire [15:0] s1;
  wire [2:0] muxB;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [15:0] CurrentOpcode;
  wire [3:0] s7;
  wire [3:0] s8;
  wire [7:0] OPcode;
  wire [2:0] s9;
  wire [15:0] AddrOut;
  wire [15:0] iow_Din;
  wire [15:0] s10;
  wire [15:0] timer_in;
  wire [15:0] RandomNUM;
  wire [15:0] FlagOut;
  wire [15:0] s11;
  wire [1:0] s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire [2:0] br;
  wire imm;
  wire [1:0] iem;
  wire pcClock;
  wire [3:0] sel;
  wire [15:0] s18;
  wire [15:0] s19;
  wire [15:0] s20;
  wire [15:0] s21;
  wire [15:0] s22;
  wire [15:0] s23;
  wire [15:0] s24;
  wire [15:0] s25;
  wire [15:0] s26;
  wire [15:0] s27;
  wire [15:0] s28;
  wire [15:0] s29;
  wire [15:0] s30;
  wire s31;
  wire s32;
  wire s33;
  wire s34;
  wire s35;
  wire s36;
  wire [4:0] aluOp;
  wire s37;
  wire s38;
  wire s39;
  wire s40;
  wire s41;
  wire s42;
  wire s43;
  wire s44;
  wire [15:0] s45;
  wire [15:0] s46;
  wire s47;
  wire ioW;
  wire s48;
  wire s49;
  wire s50;
  wire s51;
  wire s52;
  wire s53;
  wire s54;
  wire s55;
  wire s56;
  wire s57;
  wire s58;
  wire s59;
  wire s60;
  wire s61;
  wire s62;
  wire s63;
  wire s64;
  wire s65;
  wire s66;
  wire s67;
  wire s68;
  wire s69;
  wire s70;
  wire s71;
  wire s72;
  wire s73;
  wire s74;
  wire s75;
  wire s76;
  wire s77;
  wire s78;
  wire s79;
  wire s80;
  wire s81;
  wire s82;
  wire stPC;
  wire ld;
  wire RandomNUMSel;
  wire read_the_flags;
  wire [6:0] s83;
  wire [6:0] s84;
  wire s85;
  wire s86;
  wire s87;
  wire s88;
  wire s89;
  wire s90;
  wire s91;
  wire s92;
  wire s93;
  wire s94;
  wire s95;
  wire s96;
  wire s97;
  wire s98;
  wire s99;
  wire WE;
  wire sf;
  wire s100;
  wire s101;
  wire s102;
  wire s103;
  wire s104;
  wire st;
  wire abs;
  wire ioR;
  wire Reti;
  wire timer_Sel;
  wire store_the_flags;
  wire InterLock;
  wire s105;
  wire intr;
  wire s106;
  wire s107;
  wire s108;
  wire s109;
  wire interEnable;
  wire s110;
  wire [15:0] s111;
  wire s112;
  wire s113;
  wire s114;
  wire s115;
  wire [31:0] s116;
  wire s117;
  wire s118;
  wire [7:0] s119;
  wire s120;
  wire s121;
  wire [7:0] s122;
  wire rst;
  wire [15:0] timerout0;
  wire s123;
  wire spi_busy_ram;
  wire spi_clock_ram;
  wire spi_mosi_ram;
  wire s124;
  wire intsin;
  wire [15:0] s125;
  wire [15:0] s126;
  wire s127;
  wire pcShift;
  wire s128;
  wire s129;
  wire s130;
  wire s131;
  wire s132;
  wire [15:0] timerout1;
  wire s133;
  wire s134;
  wire s135;
  wire [15:0] timerout2;
  wire [1:0] s136;
  wire s137;
  wire s138;
  wire s139;
  wire spi_miso;
  assign spi_busy_ram = 1'b0;
  assign iow_Din[0] = uio_in[0];
  assign iow_Din[1] = uio_in[1];
  assign iow_Din[2] = uio_in[2];
  assign iow_Din[3] = uio_in[3];
  assign iow_Din[4] = uio_in[4];
  assign iow_Din[5] = uio_in[5];
  assign iow_Din[6] = uio_in[6];
  assign iow_Din[7] = uio_in[7];
  assign iow_Din[8] = 1'b0;
  assign iow_Din[9] = 1'b0;
  assign iow_Din[10] = 1'b0;
  assign iow_Din[11] = 1'b0;
  assign iow_Din[12] = 1'b0;
  assign iow_Din[13] = 1'b0;
  assign iow_Din[14] = 1'b0;
  assign iow_Din[15] = 1'b0;
  assign s107 = ~ clk;
  assign s109 = ~ clk;
  Driver Driver_i0 (
    .in( spi_busy_ram ),
    .sel( spi_busy_ram ),
    .out( spi_clock_ram )
  );
  Driver Driver_i1 (
    .in( spi_busy_ram ),
    .sel( spi_busy_ram ),
    .out( spi_mosi_ram )
  );
  assign s124 = ~ rst_n;
  Mux_2x1 Mux_2x1_i2 (
    .sel( spi_busy_ram ),
    .in_0( clk ),
    .in_1( 1'b1 ),
    .out( pcClock )
  );
  assign rst = ~ rst_n;
  assign s131 = ~ clk;
  assign spi_miso = ui_in[0];
  assign intsin = ui_in[1];
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i3 (
    .sel( s9 ),
    .in_0( AddrOut ),
    .in_1( 16'b0 ),
    .in_2( iow_Din ),
    .in_3( s10 ),
    .in_4( timer_in ),
    .in_5( RandomNUM ),
    .in_6( FlagOut ),
    .in_7( 16'b0 ),
    .out( s11 )
  );
  ImReg ImReg_i4 (
    .en( imm ),
    .iem( iem ),
    .C( pcClock ),
    .inst( CurrentOpcode ),
    .imm( s2 )
  );
  // *
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i5 (
    .D( s106 ),
    .C( s107 ),
    .Q( InterLock )
  );
  // *
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i6 (
    .D( s108 ),
    .C( s109 ),
    .Q( s105 )
  );
  // timer0
  timer timer_i7 (
    .dOut( DataOut ),
    .Addr( AddrOut ),
    .ioW( ioW ),
    .ioR( ioR ),
    .C( clk ),
    .InterLock( InterLock ),
    .timerConfigAddr( 16'b1 ),
    .timerTargetAddr( 16'b10 ),
    .timerResetAddr( 16'b11 ),
    .timerReadAddr( 16'b1 ),
    .rst( rst ),
    .TimerOut( timerout0 ),
    .\timer?nterrupt ( s123 )
  );
  // OpCode
  OpCode OpCode_i8 (
    .clk( pcClock ),
    .rst( s124 ),
    .instructionInput( intsin ),
    .ProgramCounter( s125 ),
    .opcoder( s126 ),
    .PcClock( s127 ),
    .PcShifter( pcShift )
  );
  // Neg
  register_1bit register_1bit_i9 (
    .D( s128 ),
    .C( clk ),
    .en( sf ),
    .rst( rst ),
    .Q( s15 )
  );
  // Zero
  register_1bit register_1bit_i10 (
    .D( s129 ),
    .C( clk ),
    .en( sf ),
    .rst( rst ),
    .Q( s14 )
  );
  // Carry
  register_1bit register_1bit_i11 (
    .D( s130 ),
    .C( clk ),
    .en( sf ),
    .rst( rst ),
    .Q( s13 )
  );
  // outputReg
  register_8bit register_8bit_i12 (
    .D( s122 ),
    .C( clk ),
    .en( s121 ),
    .rst( rst ),
    .Q( uio_oe )
  );
  // OutoutEnReg
  register_8bit register_8bit_i13 (
    .D( s119 ),
    .C( clk ),
    .en( s118 ),
    .rst( rst ),
    .Q( uio_out )
  );
  // programCounter
  programCounter programCounter_i14 (
    .AluIn( AddrOut ),
    .clk( pcClock ),
    .rst( rst ),
    .absJmp( abs ),
    .intr( s113 ),
    .reti( s114 ),
    .relJmp( s17 ),
    .Nextpc( s10 ),
    .PC( s125 )
  );
  // timer1
  timer timer_i15 (
    .dOut( DataOut ),
    .Addr( AddrOut ),
    .ioW( ioW ),
    .ioR( ioR ),
    .C( clk ),
    .InterLock( InterLock ),
    .timerConfigAddr( 16'b100 ),
    .timerTargetAddr( 16'b101 ),
    .timerResetAddr( 16'b110 ),
    .timerReadAddr( 16'b10 ),
    .rst( rst ),
    .outEn( s132 ),
    .TimerOut( timerout1 ),
    .\timer?nterrupt ( s133 )
  );
  // timer2
  timer timer_i16 (
    .dOut( DataOut ),
    .Addr( AddrOut ),
    .ioW( ioW ),
    .ioR( ioR ),
    .C( clk ),
    .InterLock( InterLock ),
    .timerConfigAddr( 16'b111 ),
    .timerTargetAddr( 16'b1000 ),
    .timerResetAddr( 16'b1001 ),
    .timerReadAddr( 16'b11 ),
    .rst( rst ),
    .outEn( s135 ),
    .TimerOut( timerout2 ),
    .\timer?nterrupt ( s134 )
  );
  RegisterBlock RegisterBlock_i17 (
    .DataIn( s11 ),
    .WE( WE ),
    .clk( pcClock ),
    .src( s7 ),
    .Dest( s8 ),
    .rst( rst ),
    .RDest( s0 ),
    .Rsrc( DataOut )
  );
  assign uo_out[0] = pcShift;
  assign uo_out[1] = spi_clock_ram;
  assign uo_out[2] = spi_mosi_ram;
  assign uo_out[3] = ~ spi_busy_ram;
  assign uo_out[4] = 1'b0;
  assign uo_out[5] = 1'b0;
  assign uo_out[6] = 1'b0;
  assign uo_out[7] = 1'b0;
  assign FlagOut[0] = s13;
  assign FlagOut[1] = s14;
  assign FlagOut[2] = s15;
  assign FlagOut[15:3] = 13'b0;
  // pgr
  DIG_ROM_65536X16_pgr DIG_ROM_65536X16_pgr_i18 (
    .A( s125 ),
    .sel( 1'b1 ),
    .D( CurrentOpcode )
  );
  assign s136[0] = s132;
  assign s136[1] = s135;
  assign s119 = DataOut[7:0];
  assign s122 = DataOut[7:0];
  singExtend singExtend_i19 (
    .inst( CurrentOpcode ),
    .\4S ( s3 ),
    .\8SD ( s4 ),
    .\4D ( s5 )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i20 (
    .sel( s136 ),
    .in_0( timerout0 ),
    .in_1( timerout1 ),
    .in_2( timerout2 ),
    .in_3( timerout2 ),
    .out( timer_in )
  );
  assign s7 = CurrentOpcode[3:0];
  assign s8 = CurrentOpcode[7:4];
  assign OPcode = CurrentOpcode[15:8];
  assign s83 = OPcode[6:0];
  assign imm = OPcode[7];
  Mux_2x1_NBits #(
    .Bits(7)
  )
  Mux_2x1_NBits_i21 (
    .sel( imm ),
    .in_0( s83 ),
    .in_1( 7'b0 ),
    .out( s84 )
  );
  assign intr = (~ InterLock & ~ imm & s105 & ~ 1'b0);
  assign s91 = s84[0];
  assign s90 = s84[1];
  assign s89 = s84[2];
  assign s88 = s84[3];
  assign s87 = s84[4];
  assign s86 = s84[5];
  assign s85 = s84[6];
  controllogic controllogic_i22 (
    .A( s85 ),
    .B( s86 ),
    .C( s87 ),
    .D( s88 ),
    .E( s89 ),
    .F( s90 ),
    .G( s91 ),
    .muxb0( s92 ),
    .muxb1( s93 ),
    .muxb2( s94 ),
    .aluop0( s95 ),
    .aluop1( s96 ),
    .aluop2( s97 ),
    .aluop3( s98 ),
    .aluop4( s99 ),
    .WE( WE ),
    .sf( sf ),
    .iem0( s100 ),
    .iem1( s101 ),
    .br0( s102 ),
    .br1( s103 ),
    .br2( s104 ),
    .muxA( muxA ),
    .ld( ld ),
    .st( st ),
    .abs( abs ),
    .ioW( ioW ),
    .ioR( ioR ),
    .stPC( stPC ),
    .Reti( Reti ),
    .randomSel( RandomNUMSel ),
    .timerSel( timer_Sel ),
    .\read-flags ( read_the_flags ),
    .storeFlagI( store_the_flags )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i23 (
    .sel( muxA ),
    .in_0( s0 ),
    .in_1( DataOut ),
    .out( s1 )
  );
  assign s9[0] = (stPC | ld | RandomNUMSel);
  assign s9[1] = ((ioR & ~ timer_Sel) | read_the_flags | stPC);
  assign s9[2] = (timer_Sel | read_the_flags | RandomNUMSel);
  assign muxB[0] = s94;
  assign muxB[1] = s93;
  assign muxB[2] = s92;
  assign aluOp[0] = s99;
  assign aluOp[1] = s98;
  assign aluOp[2] = s97;
  assign aluOp[3] = s96;
  assign aluOp[4] = s95;
  assign br[0] = s104;
  assign br[1] = s103;
  assign br[2] = s102;
  assign iem[0] = s101;
  assign iem[1] = s100;
  assign s106 = ((InterLock & ~ Reti) | intr);
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i24 (
    .sel( muxB ),
    .in_0( DataOut ),
    .in_1( 16'b0 ),
    .in_2( s2 ),
    .in_3( 16'b0 ),
    .in_4( 16'b0 ),
    .in_5( s3 ),
    .in_6( s4 ),
    .in_7( s5 ),
    .out( s6 )
  );
  assign s37 = (aluOp[4] & s13);
  assign s23 = ~ s1;
  DIG_Neg #(
    .Bits(16)
  )
  DIG_Neg_i25 (
    .in( s1 ),
    .out( s24 )
  );
  assign s29[3:0] = s1[7:4];
  assign s29[7:4] = s1[3:0];
  assign s29[11:8] = s1[15:12];
  assign s29[15:12] = s1[11:8];
  assign s28[7:0] = s1[15:8];
  assign s28[15:8] = s1[7:0];
  assign s12 = br[1:0];
  assign sel = aluOp[3:0];
  assign s35 = s1[0];
  assign s115 = s1[15];
  assign s34 = s1[0];
  assign s33 = s1[15];
  assign s137 = s1[0];
  assign s138 = s1[1];
  assign s139 = s1[2];
  Mux_4x1 Mux_4x1_i26 (
    .sel( s12 ),
    .in_0( 1'b0 ),
    .in_1( s13 ),
    .in_2( s14 ),
    .in_3( s15 ),
    .out( s16 )
  );
  assign s20 = (s1 & s6);
  assign s21 = (s1 | s6);
  assign s22 = (s1 ^ s6);
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i27 (
    .a( s1 ),
    .b( s6 ),
    .c_i( s37 ),
    .s( s18 ),
    .c_o( s31 )
  );
  DIG_Sub #(
    .Bits(16)
  )
  DIG_Sub_i28 (
    .a( s1 ),
    .b( s6 ),
    .c_i( s37 ),
    .s( s19 ),
    .c_o( s32 )
  );
  assign s27[13:0] = s1[14:1];
  assign s27[14] = s115;
  assign s27[15] = s115;
  assign s26[14:0] = s1[15:1];
  assign s26[15] = s37;
  assign s25[0] = s37;
  assign s25[15:1] = s1[14:0];
  DIG_Mul_unsigned #(
    .Bits(16)
  )
  DIG_Mul_unsigned_i29 (
    .a( s1 ),
    .b( s6 ),
    .mul( s116 )
  );
  assign s17 = (s16 ^ br[2]);
  Mux_16x1 Mux_16x1_i30 (
    .sel( sel ),
    .in_0( 1'b0 ),
    .in_1( s31 ),
    .in_2( s32 ),
    .in_3( 1'b0 ),
    .in_4( 1'b0 ),
    .in_5( 1'b0 ),
    .in_6( 1'b0 ),
    .in_7( 1'b0 ),
    .in_8( s33 ),
    .in_9( s34 ),
    .in_10( s35 ),
    .in_11( 1'b0 ),
    .in_12( 1'b0 ),
    .in_13( 1'b0 ),
    .in_14( 1'b0 ),
    .in_15( 1'b0 ),
    .out( s36 )
  );
  assign s30 = s116[15:0];
  Mux_16x1_NBits #(
    .Bits(16)
  )
  Mux_16x1_NBits_i31 (
    .sel( sel ),
    .in_0( s6 ),
    .in_1( s18 ),
    .in_2( s19 ),
    .in_3( s20 ),
    .in_4( s21 ),
    .in_5( s22 ),
    .in_6( s23 ),
    .in_7( s24 ),
    .in_8( s25 ),
    .in_9( s26 ),
    .in_10( s27 ),
    .in_11( s28 ),
    .in_12( s29 ),
    .in_13( s30 ),
    .in_14( 16'b0 ),
    .in_15( 16'b0 ),
    .out( AddrOut )
  );
  Mux_2x1 Mux_2x1_i32 (
    .sel( store_the_flags ),
    .in_0( s36 ),
    .in_1( s137 ),
    .out( s130 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i33 (
    .a( AddrOut ),
    .b( 16'b0 ),
    .\= ( s38 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i34 (
    .a( AddrOut ),
    .b( 16'b1101 ),
    .\= ( s47 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i35 (
    .a( AddrOut ),
    .b( 16'b1010 ),
    .\= ( s112 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i36 (
    .a( AddrOut ),
    .b( 16'b1011 ),
    .\= ( s117 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i37 (
    .a( AddrOut ),
    .b( 16'b1100 ),
    .\= ( s120 )
  );
  assign s39 = AddrOut[15];
  assign s44 = (s47 & ioW);
  assign s110 = (s112 & ioW);
  assign s118 = (s117 & ioW);
  assign s121 = (s120 & ioW);
  Mux_2x1 Mux_2x1_i38 (
    .sel( store_the_flags ),
    .in_0( s38 ),
    .in_1( s138 ),
    .out( s129 )
  );
  Mux_2x1 Mux_2x1_i39 (
    .sel( store_the_flags ),
    .in_0( s39 ),
    .in_1( s139 ),
    .out( s128 )
  );
  // seed
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i40 (
    .D( DataOut ),
    .C( clk ),
    .en( s44 ),
    .Q( s45 )
  );
  assign s41 = (clk & s44);
  // intEn
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i41 (
    .D( DataOut ),
    .C( clk ),
    .en( s110 ),
    .Q( s111 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i42 (
    .sel( s44 ),
    .in_0( 16'b0 ),
    .in_1( s45 ),
    .out( s46 )
  );
  assign interEnable = s111[0];
  assign s108 = ((s105 & ~ Reti) | ((s123 | s133 | s134) & interEnable));
  assign s113 = (intr & interEnable);
  assign s114 = (interEnable & Reti);
  assign s50 = s46[0];
  assign s53 = s46[1];
  assign s55 = s46[2];
  assign s57 = s46[3];
  assign s59 = s46[4];
  assign s61 = s46[5];
  assign s63 = s46[6];
  assign s65 = s46[7];
  assign s67 = s46[8];
  assign s69 = s46[9];
  assign s71 = s46[10];
  assign s73 = s46[11];
  assign s75 = s46[12];
  assign s77 = s46[13];
  assign s79 = s46[14];
  assign s81 = s46[15];
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i43 (
    .Set( 1'b0 ),
    .D( s40 ),
    .C( s41 ),
    .Clr( s42 ),
    .Q( s43 ),
    .\~Q ( s40 )
  );
  assign s49 = (s44 & ~ s48);
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i44 (
    .Set( s50 ),
    .D( s51 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s52 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i45 (
    .Set( s53 ),
    .D( s52 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s54 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i46 (
    .Set( s55 ),
    .D( s54 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s56 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i47 (
    .Set( s57 ),
    .D( s56 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s58 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i48 (
    .Set( s59 ),
    .D( s58 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s60 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i49 (
    .Set( s61 ),
    .D( s60 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s62 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i50 (
    .Set( s63 ),
    .D( s62 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s64 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i51 (
    .Set( s65 ),
    .D( s64 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s66 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i52 (
    .Set( s67 ),
    .D( s66 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s68 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i53 (
    .Set( s69 ),
    .D( s68 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s70 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i54 (
    .Set( s71 ),
    .D( s70 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s72 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i55 (
    .Set( s73 ),
    .D( s72 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s74 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i56 (
    .Set( s75 ),
    .D( s74 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s76 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i57 (
    .Set( s77 ),
    .D( s76 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s78 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i58 (
    .Set( s79 ),
    .D( s78 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s80 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i59 (
    .Set( s81 ),
    .D( s80 ),
    .C( clk ),
    .Clr( s49 ),
    .Q( s82 )
  );
  assign s51 = (s62 ^ (s72 ^ (s76 ^ s80)));
  assign RandomNUM[0] = s52;
  assign RandomNUM[1] = s54;
  assign RandomNUM[2] = s56;
  assign RandomNUM[3] = s58;
  assign RandomNUM[4] = s60;
  assign RandomNUM[5] = s62;
  assign RandomNUM[6] = s64;
  assign RandomNUM[7] = s66;
  assign RandomNUM[8] = s68;
  assign RandomNUM[9] = s70;
  assign RandomNUM[10] = s72;
  assign RandomNUM[11] = s74;
  assign RandomNUM[12] = s76;
  assign RandomNUM[13] = s78;
  assign RandomNUM[14] = s80;
  assign RandomNUM[15] = s82;
  assign s48 = (s43 | s42);
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i60 (
    .J( s48 ),
    .C( clk ),
    .K( s48 ),
    .Q( s42 )
  );
endmodule
