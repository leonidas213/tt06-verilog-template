/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module singExtend (
  input [15:0] inst, // instruction word
  output [15:0] \4S , // The four bits taken from Rs.
  output [15:0] \8SD , // The eight bits taken from Rs,Rd with sign extension.
  output [15:0] \4D  // The four bits taken from Rd.

);
  wire s0;
  assign \4D [3:0] = inst[7:4];
  assign \4D [15:4] = 12'b0;
  assign \4S [3:0] = inst[3:0];
  assign \4S [15:4] = 12'b0;
  assign s0 = inst[7];
  assign \8SD [6:0] = inst[6:0];
  assign \8SD [7] = s0;
  assign \8SD [8] = s0;
  assign \8SD [9] = s0;
  assign \8SD [10] = s0;
  assign \8SD [11] = s0;
  assign \8SD [12] = s0;
  assign \8SD [13] = s0;
  assign \8SD [14] = s0;
  assign \8SD [15] = s0;
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module controllogic (
  input A,
  input B,
  input C,
  input D,
  input E,
  input F,
  input G,
  output muxb0,
  output muxb1,
  output muxb2,
  output src2D,
  output aluop0,
  output aluop1,
  output aluop2,
  output aluop3,
  output aluop4,
  output WE,
  output sf,
  output alu2D,
  output iem0,
  output iem1,
  output br0,
  output br1,
  output br2,
  output muxA,
  output ld,
  output st,
  output abs,
  output ioW,
  output ioR,
  output stPC,
  output Reti,
  output randomSel,
  output timerSel
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  assign s6 = ~ A;
  assign s0 = ~ B;
  assign s1 = ~ C;
  assign s2 = ~ D;
  assign s3 = ~ E;
  assign s5 = ~ F;
  assign s4 = ~ G;
  assign muxb0 = ((A & s0 & s1 & s2 & s3 & F & s4) | (A & s0 & s1 & s2 & E & F & G) | (A & s0 & s1 & D & s3 & s5 & s4) | (s6 & s1 & D & E & F & s4) | (s6 & B & C & s3 & s5 & s4) | (s6 & s0 & s1 & D & F & s4) | (s6 & s0 & s1 & D & E & s4) | (s6 & s0 & C & s2 & s3 & s4) | (s6 & B & s1 & s2 & s3 & G) | (s6 & C & D & s5 & G) | (s6 & C & s2 & E & G) | (s6 & B & C & E & G) | (s6 & B & C & s2 & E));
  assign muxb1 = ((A & s0 & s1 & s2 & E & F & s4) | (s6 & C & s2 & s3 & s5 & G) | (s6 & B & s1 & s2 & s3 & s4) | (A & s0 & s1 & s2 & s3 & G) | (A & s0 & s1 & s2 & s3 & s5) | (s6 & s1 & D & F & G) | (s6 & C & D & s5 & s4) | (s6 & B & C & s5 & G) | (s6 & B & C & F & s4) | (s6 & C & s2 & E & s4) | (s6 & s0 & s1 & D & G) | (s6 & B & D & E) | (s6 & B & C & E));
  assign muxb2 = ((s6 & B & C & D & E & F & G) | (s6 & C & s2 & s3 & s5 & s4) | (s6 & B & s2 & s3 & F & G) | (s6 & B & s1 & s3 & F & G) | (A & s0 & s1 & s3 & s5 & s4) | (s6 & s0 & s1 & D & F & s4) | (s6 & s0 & C & D & s5 & G) | (A & s0 & s1 & s2 & F & G) | (s6 & s0 & C & s2 & s3 & s4) | (s6 & s0 & C & s2 & E & G) | (s6 & B & s1 & s2 & s3 & G) | (A & s0 & s1 & s2 & s3 & s4) | (s6 & s1 & D & E & s4));
  assign src2D = ((s6 & s0 & s1 & s2 & s3 & s5 & G) | (s6 & B & s1 & D & s3 & F & G) | (s6 & B & s1 & D & E & s5 & G) | (s6 & B & C & s2 & s3 & s5 & G) | (A & s0 & s1 & s2 & s3 & s5 & s4) | (s6 & B & D & E & F & s4) | (s6 & B & C & D & E & F));
  assign aluop0 = ((s6 & s0 & s1 & D & E & F & s4) | (s6 & s0 & C & s2 & s3 & s5 & G) | (s6 & s0 & C & s2 & s3 & F & s4) | (s6 & s0 & C & D & E & F & G) | (s6 & s1 & s2 & s3 & F & G) | (s6 & s0 & s1 & E & s5 & G) | (s6 & B & s1 & s2 & F));
  assign aluop1 = ((s6 & s0 & C & D & s3 & F & G) | (A & s0 & s1 & s2 & E & s5 & G) | (A & s0 & s1 & s2 & E & F & s4) | (s6 & B & s1 & D & s3 & s4) | (s6 & s0 & C & D & E & s5) | (s6 & B & s1 & D & s3 & s5) | (s6 & B & s1 & s2 & E));
  assign aluop2 = ((s6 & B & s1 & D & s3 & F & s4) | (A & s0 & s1 & s2 & E & s5 & G) | (A & s0 & s1 & s2 & E & F & s4) | (s6 & s0 & s2 & E & F & G) | (s6 & s0 & D & s3 & s5 & s4) | (s6 & s0 & C & s3 & F & G) | (s6 & s0 & C & s2 & E & F) | (s6 & s0 & C & D & s5) | (s6 & s0 & C & D & s3));
  assign aluop3 = ((s6 & s0 & D & E & F & G) | (s6 & s0 & C & D & F & s4) | (s6 & s0 & s2 & E & s5) | (s6 & B & s1 & s3 & s5) | (s6 & s0 & C & s2 & s3) | (s6 & B & s1 & s2 & s3) | (s0 & s1 & s2 & E & s5 & G) | (s0 & s1 & s2 & E & F & s4));
  assign aluop4 = ((s6 & B & C & s2 & s3 & s5 & G) | (s6 & B & C & s2 & s3 & F & s4) | (A & s0 & s1 & s2 & s3 & s5 & s4) | (s6 & s1 & D & E & s5 & s4) | (s6 & s0 & s1 & E & F & s4) | (s6 & s0 & s1 & s2 & F & s4) | (s6 & s0 & C & D & s3 & G) | (s6 & B & s1 & s2 & E & G) | (s6 & B & s1 & D & s3 & G) | (s6 & s0 & s3 & F & G) | (s6 & s0 & D & s5 & s4) | (s6 & s0 & D & E & s5) | (s6 & s0 & C & E & s5) | (s0 & s1 & s2 & s3 & F & G));
  assign WE = ((s6 & D & s3 & F & s4) | (s6 & s1 & E & s5 & s4) | (s6 & s1 & E & F & G) | (s6 & C & s2 & s3 & s4) | (s6 & s1 & D & s3 & s5) | (s6 & C & s2 & s3 & F) | (s6 & s0 & D & s5) | (s6 & s1 & s2 & E) | (s6 & s0 & D & s3) | (s6 & s0 & s1 & D) | (s6 & s0 & C & s2) | (s0 & s1 & D & s3 & s5 & s4) | (s0 & s1 & s2 & G) | (s0 & s1 & s2 & F));
  assign sf = ((s6 & s1 & D & s3 & s5 & s4) | (s6 & s0 & s2 & F & s4) | (s6 & s0 & D & F & G) | (s6 & s0 & s1 & F & G) | (s6 & s0 & C & s5) | (s6 & B & s1 & s2) | (s6 & s0 & E) | (s0 & s1 & s2 & E & s5 & G) | (s0 & s1 & s2 & E & F & s4));
  assign alu2D = ((s6 & C & s2 & s3 & F & G) | (s6 & s1 & D & s3 & s4) | (s6 & s1 & D & s3 & s5) | (s6 & s0 & E & s5) | (s6 & s0 & s2 & F) | (s6 & s0 & s1 & F) | (s6 & s1 & s2 & E) | (s6 & s0 & C & s3) | (s0 & s1 & s2 & E & s5 & G) | (s0 & s1 & s2 & E & F & s4));
  assign iem0 = ((s6 & s0 & C & s2 & s3 & s5 & G) | (A & s0 & s1 & s2 & s3 & s5 & G) | (A & s0 & s1 & s2 & E & F & s4) | (s6 & C & D & E & s5 & s4) | (s6 & s0 & C & D & s5 & s4) | (s6 & B & C & D & F & s4) | (s6 & s0 & C & s2 & E & s4) | (s6 & B & s1 & s2 & s3 & s4) | (s6 & s1 & D & E & G) | (s6 & s0 & s1 & D & G));
  assign iem1 = ((s6 & B & s1 & D & E & s5 & G) | (s6 & B & C & D & E & F & s4));
  assign br0 = ((s6 & B & C & s2 & E & F & G) | (s6 & B & C & D & s5 & G) | (s6 & B & C & D & s3 & s5));
  assign br1 = ((s6 & B & C & s2 & E & s5 & G) | (s6 & B & C & s2 & E & F & s4) | (s6 & B & C & D & s3 & s5));
  assign br2 = ((s6 & B & C & D & s3 & s5 & G) | (s6 & B & C & s2 & E & s4) | (s6 & B & C & s2 & E & F));
  assign muxA = ((s6 & B & s1 & D & E & s5 & s4) | (s6 & B & C & s2 & s3 & F & s4) | (A & s0 & s1 & s2 & s3 & G) | (A & s0 & s1 & s2 & s3 & F));
  assign ld = ((s6 & B & s1 & D & E & s5 & s4) | (s6 & B & s1 & D & E & F & G) | (s6 & B & C & s2 & s3 & s4));
  assign st = ((s6 & B & s1 & D & s3 & F & G) | (s6 & B & s1 & D & E & s5 & G) | (s6 & B & s1 & D & E & F & s4) | (s6 & B & C & s2 & s3 & s5 & G));
  assign abs = ((s6 & B & C & D & E & s5 & s4) | (A & s0 & s1 & s2 & E & s5 & s4) | (s6 & B & C & D & s3 & F));
  assign ioW = ((A & s0 & s1 & s2 & s3 & s5 & s4) | (s6 & B & C & D & E & F));
  assign ioR = ((A & s0 & s1 & s2 & s3 & G) | (A & s0 & s1 & s2 & s3 & F));
  assign stPC = (s6 & B & C & D & s3 & F & s4);
  assign Reti = (A & s0 & s1 & s2 & E & s5 & s4);
  assign randomSel = (A & s0 & s1 & s2 & E & F & G);
  assign timerSel = (A & s0 & s1 & D & s3 & s5 & s4);
endmodule

module Mux_4x1
(
    input [1:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    output reg out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


// Register for storing large constants.
// There is a 1-bit command describing this register. 
// In this way, 15 bits can be stored (the 16th bit 
// activates the writing of this register and therefore 
// is always one). The 16th bit will be set according 
// to the 'immediate extend mode' (iem).
module ImReg (
  input en, // enables storage
  input [1:0] iem, // immediate extend mode (0: sign extend; 1: extend with 0, 2:extend with S0, 3:extend with D0)
  input C,
  input [15:0] inst, // the current instruction
  output [15:0] imm // The constant of register contents and bit 8.

);
  wire [14:0] s0;
  wire [14:0] s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  assign s2 = inst[0];
  assign s3 = inst[4];
  assign s0 = inst[14:0];
  // imm
  DIG_Register_BUS #(
    .Bits(15)
  )
  DIG_Register_BUS_i0 (
    .D( s0 ),
    .C( C ),
    .en( en ),
    .Q( s1 )
  );
  assign s5 = s1[14];
  Mux_4x1 Mux_4x1_i1 (
    .sel( iem ),
    .in_0( s5 ),
    .in_1( 1'b0 ),
    .in_2( s2 ),
    .in_3( s3 ),
    .out( s4 )
  );
  assign imm[14:0] = s1;
  assign imm[15] = s4;
endmodule

module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_RAMDualPort
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] Din,
  input str,
  input C,
  input ld,
  output [(Bits-1):0] D
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign D = ld? memory[A] : 'hz;

  always @ (posedge C) begin
    if (str)
      memory[A] <= Din;
  end
endmodule


module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Demux4
#(
    parameter Default = 0 
)
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    output out_8,
    output out_9,
    output out_10,
    output out_11,
    output out_12,
    output out_13,
    output out_14,
    output out_15,
    input [3:0] sel,
    input in
);
    assign out_0 = (sel == 4'h0)? in : Default;
    assign out_1 = (sel == 4'h1)? in : Default;
    assign out_2 = (sel == 4'h2)? in : Default;
    assign out_3 = (sel == 4'h3)? in : Default;
    assign out_4 = (sel == 4'h4)? in : Default;
    assign out_5 = (sel == 4'h5)? in : Default;
    assign out_6 = (sel == 4'h6)? in : Default;
    assign out_7 = (sel == 4'h7)? in : Default;
    assign out_8 = (sel == 4'h8)? in : Default;
    assign out_9 = (sel == 4'h9)? in : Default;
    assign out_10 = (sel == 4'ha)? in : Default;
    assign out_11 = (sel == 4'hb)? in : Default;
    assign out_12 = (sel == 4'hc)? in : Default;
    assign out_13 = (sel == 4'hd)? in : Default;
    assign out_14 = (sel == 4'he)? in : Default;
    assign out_15 = (sel == 4'hf)? in : Default;
endmodule


module Mux_16x1_NBits #(
    parameter Bits = 2
)
(
    input [3:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    input [(Bits - 1):0] in_8,
    input [(Bits - 1):0] in_9,
    input [(Bits - 1):0] in_10,
    input [(Bits - 1):0] in_11,
    input [(Bits - 1):0] in_12,
    input [(Bits - 1):0] in_13,
    input [(Bits - 1):0] in_14,
    input [(Bits - 1):0] in_15,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            4'h0: out = in_0;
            4'h1: out = in_1;
            4'h2: out = in_2;
            4'h3: out = in_3;
            4'h4: out = in_4;
            4'h5: out = in_5;
            4'h6: out = in_6;
            4'h7: out = in_7;
            4'h8: out = in_8;
            4'h9: out = in_9;
            4'ha: out = in_10;
            4'hb: out = in_11;
            4'hc: out = in_12;
            4'hd: out = in_13;
            4'he: out = in_14;
            4'hf: out = in_15;
            default:
                out = 'h0;
        endcase
    end
endmodule


module RegisterBlock (
  input [15:0] DataIn,
  input WE,
  input clk,
  input [3:0] src,
  input [3:0] Dest,
  output [15:0] RDest,
  output [15:0] Rsrc
);
  wire s0;
  wire [15:0] s1;
  wire s2;
  wire [15:0] s3;
  wire s4;
  wire [15:0] s5;
  wire s6;
  wire [15:0] s7;
  wire s8;
  wire [15:0] s9;
  wire s10;
  wire [15:0] s11;
  wire s12;
  wire [15:0] s13;
  wire s14;
  wire [15:0] s15;
  wire s16;
  wire [15:0] s17;
  wire s18;
  wire [15:0] s19;
  wire s20;
  wire [15:0] s21;
  wire s22;
  wire [15:0] s23;
  wire s24;
  wire [15:0] s25;
  wire s26;
  wire [15:0] s27;
  wire s28;
  wire [15:0] s29;
  wire s30;
  wire [15:0] s31;
  Demux4 #(
    .Default(0)
  )
  Demux4_i0 (
    .sel( Dest ),
    .in( WE ),
    .out_0( s0 ),
    .out_1( s2 ),
    .out_2( s4 ),
    .out_3( s6 ),
    .out_4( s8 ),
    .out_5( s10 ),
    .out_6( s12 ),
    .out_7( s14 ),
    .out_8( s16 ),
    .out_9( s18 ),
    .out_10( s20 ),
    .out_11( s22 ),
    .out_12( s24 ),
    .out_13( s26 ),
    .out_14( s28 ),
    .out_15( s30 )
  );
  // R0
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( DataIn ),
    .C( clk ),
    .en( s0 ),
    .Q( s1 )
  );
  // R1
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i2 (
    .D( DataIn ),
    .C( clk ),
    .en( s2 ),
    .Q( s3 )
  );
  // R2
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( DataIn ),
    .C( clk ),
    .en( s4 ),
    .Q( s5 )
  );
  // R3
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( DataIn ),
    .C( clk ),
    .en( s6 ),
    .Q( s7 )
  );
  // R4
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( DataIn ),
    .C( clk ),
    .en( s8 ),
    .Q( s9 )
  );
  // R5
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i6 (
    .D( DataIn ),
    .C( clk ),
    .en( s10 ),
    .Q( s11 )
  );
  // R6
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i7 (
    .D( DataIn ),
    .C( clk ),
    .en( s12 ),
    .Q( s13 )
  );
  // R7
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i8 (
    .D( DataIn ),
    .C( clk ),
    .en( s14 ),
    .Q( s15 )
  );
  // R8
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i9 (
    .D( DataIn ),
    .C( clk ),
    .en( s16 ),
    .Q( s17 )
  );
  // R9
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i10 (
    .D( DataIn ),
    .C( clk ),
    .en( s18 ),
    .Q( s19 )
  );
  // R10
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i11 (
    .D( DataIn ),
    .C( clk ),
    .en( s20 ),
    .Q( s21 )
  );
  // R11
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i12 (
    .D( DataIn ),
    .C( clk ),
    .en( s22 ),
    .Q( s23 )
  );
  // R12
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i13 (
    .D( DataIn ),
    .C( clk ),
    .en( s24 ),
    .Q( s25 )
  );
  // BP
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i14 (
    .D( DataIn ),
    .C( clk ),
    .en( s26 ),
    .Q( s27 )
  );
  // SP
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i15 (
    .D( DataIn ),
    .C( clk ),
    .en( s28 ),
    .Q( s29 )
  );
  // RA
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i16 (
    .D( DataIn ),
    .C( clk ),
    .en( s30 ),
    .Q( s31 )
  );
  Mux_16x1_NBits #(
    .Bits(16)
  )
  Mux_16x1_NBits_i17 (
    .sel( Dest ),
    .in_0( s1 ),
    .in_1( s3 ),
    .in_2( s5 ),
    .in_3( s7 ),
    .in_4( s9 ),
    .in_5( s11 ),
    .in_6( s13 ),
    .in_7( s15 ),
    .in_8( s17 ),
    .in_9( s19 ),
    .in_10( s21 ),
    .in_11( s23 ),
    .in_12( s25 ),
    .in_13( s27 ),
    .in_14( s29 ),
    .in_15( s31 ),
    .out( RDest )
  );
  Mux_16x1_NBits #(
    .Bits(16)
  )
  Mux_16x1_NBits_i18 (
    .sel( src ),
    .in_0( s1 ),
    .in_1( s3 ),
    .in_2( s5 ),
    .in_3( s7 ),
    .in_4( s9 ),
    .in_5( s11 ),
    .in_6( s13 ),
    .in_7( s15 ),
    .in_8( s17 ),
    .in_9( s19 ),
    .in_10( s21 ),
    .in_11( s23 ),
    .in_12( s25 ),
    .in_13( s27 ),
    .in_14( s29 ),
    .in_15( s31 ),
    .out( Rsrc )
  );
endmodule

module Mux_16x1
(
    input [3:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    input in_4,
    input in_5,
    input in_6,
    input in_7,
    input in_8,
    input in_9,
    input in_10,
    input in_11,
    input in_12,
    input in_13,
    input in_14,
    input in_15,
    output reg out
);
    always @ (*) begin
        case (sel)
            4'h0: out = in_0;
            4'h1: out = in_1;
            4'h2: out = in_2;
            4'h3: out = in_3;
            4'h4: out = in_4;
            4'h5: out = in_5;
            4'h6: out = in_6;
            4'h7: out = in_7;
            4'h8: out = in_8;
            4'h9: out = in_9;
            4'ha: out = in_10;
            4'hb: out = in_11;
            4'hc: out = in_12;
            4'hd: out = in_13;
            4'he: out = in_14;
            4'hf: out = in_15;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_JK_FF
#(
    parameter Default = 1'b0
)
(
   input J,
   input C,
   input K,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        if (~J & K)
            state <= 1'b0;
         else if (J & ~K)
            state <= 1'b1;
         else if (J & K)
            state <= ~state;
    end

    initial begin
        state = Default;
    end
endmodule


module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule


module DIG_Neg #(
    parameter Bits = 1
)
(
      input signed [(Bits-1):0] in,
      output signed [(Bits-1):0] out
);
    assign out = -in;
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule


module DIG_Mul_unsigned #(
    parameter Bits = 1
)
(
    
      input [(Bits-1):0] a,
      input [(Bits-1):0] b,
      output [(Bits*2-1):0] mul
    
);
    assign mul = a * b;
endmodule


module Mux_8x1
(
    input [2:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    input in_4,
    input in_5,
    input in_6,
    input in_7,
    output reg out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_CounterPreset #(
    parameter Bits = 2,
    parameter maxValue = 4
)
(
    input C,
    input en,
    input clr,
    input dir,
    input [(Bits-1):0] in,
    input ld,
    output [(Bits-1):0] out,
    output ovf
);

    reg [(Bits-1):0] count = 'h0;

    function [(Bits-1):0] maxVal (input [(Bits-1):0] maxv);
        if (maxv == 0)
            maxVal = (1 << Bits) - 1;
        else
            maxVal = maxv;
    endfunction

    assign out = count;
    assign ovf = ((count == maxVal(maxValue) & dir == 1'b0)
                  | (count == 'b0 & dir == 1'b1))? en : 1'b0;

    always @ (posedge C) begin
        if (clr == 1'b1)
            count <= 'h0;
        else if (ld == 1'b1)
            count <= in;
        else if (en == 1'b1) begin
            if (dir == 1'b0) begin
                if (count == maxVal(maxValue))
                    count <= 'h0;
                else
                    count <= count + 1'b1;
            end
            else begin
                if (count == 'h0)
                    count <= maxVal(maxValue);
                else
                    count <= count - 1;
            end
        end
    end
endmodule


module tt_um_smallcpu (
  input [7:0] ui_in,
  input [7:0] uio_in,
  input ena,
  input clk,
  input rst_n,
  output [7:0] uo_out,
  output [7:0] uio_out,
  output [7:0] uio_oe
);
  wire muxA;
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [2:0] muxB;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [15:0] s7;
  wire [15:0] s8;
  wire [3:0] s9;
  wire [3:0] s10;
  wire [7:0] OPcode;
  wire [4:0] s11;
  wire s12;
  wire C;
  wire s13;
  wire [15:0] s14;
  wire [2:0] s15;
  wire [15:0] s16;
  wire [15:0] s17;
  wire [15:0] Din;
  wire [15:0] s18;
  wire [15:0] timer_in;
  wire [15:0] RandomNUM;
  wire [15:0] s19;
  wire [1:0] s20;
  wire s21;
  wire s22;
  wire s23;
  wire s24;
  wire s25;
  wire [2:0] br;
  wire s26;
  wire sf;
  wire s27;
  wire s28;
  wire [15:0] FlagOut;
  wire WE;
  wire imm;
  wire [1:0] iem;
  wire [11:0] s29;
  wire s30;
  wire s31;
  wire [11:0] pcOut;
  wire [11:0] s32;
  wire [11:0] s33;
  wire [11:0] s34;
  wire abs;
  wire [11:0] s35;
  wire [11:0] s36;
  wire s37;
  wire ioW;
  wire s38;
  wire [3:0] s39;
  wire [3:0] outputToOutside;
  wire [3:0] sel;
  wire [15:0] s40;
  wire [15:0] s41;
  wire [15:0] s42;
  wire [15:0] s43;
  wire [15:0] s44;
  wire [15:0] s45;
  wire [15:0] s46;
  wire [15:0] s47;
  wire [15:0] s48;
  wire [15:0] s49;
  wire [15:0] s50;
  wire [15:0] s51;
  wire [15:0] s52;
  wire s53;
  wire s54;
  wire s55;
  wire s56;
  wire s57;
  wire [4:0] aluOp;
  wire s58;
  wire s59;
  wire s60;
  wire s61;
  wire s62;
  wire s63;
  wire [15:0] s64;
  wire [15:0] s65;
  wire s66;
  wire s67;
  wire s68;
  wire s69;
  wire s70;
  wire s71;
  wire s72;
  wire s73;
  wire s74;
  wire s75;
  wire s76;
  wire s77;
  wire s78;
  wire s79;
  wire s80;
  wire s81;
  wire s82;
  wire s83;
  wire s84;
  wire s85;
  wire s86;
  wire s87;
  wire s88;
  wire s89;
  wire s90;
  wire s91;
  wire s92;
  wire s93;
  wire s94;
  wire s95;
  wire s96;
  wire s97;
  wire s98;
  wire s99;
  wire s100;
  wire s101;
  wire stPC;
  wire ld;
  wire RandomNUMSel;
  wire ioR;
  wire [6:0] s102;
  wire [6:0] s103;
  wire s104;
  wire s105;
  wire s106;
  wire s107;
  wire s108;
  wire s109;
  wire s110;
  wire s111;
  wire s112;
  wire s113;
  wire src2D;
  wire s114;
  wire s115;
  wire s116;
  wire s117;
  wire s118;
  wire alu2D;
  wire s119;
  wire s120;
  wire s121;
  wire s122;
  wire s123;
  wire st;
  wire Reti;
  wire timer_Sel;
  wire s124;
  wire s125;
  wire [3:0] s126;
  wire [3:0] outputToOutsideEnable;
  wire s127;
  wire s128;
  wire [7:0] s129;
  wire s130;
  wire [7:0] s131;
  wire [1:0] s132;
  wire s133;
  wire s134;
  wire s135;
  wire s136;
  wire s137;
  wire s138;
  wire [2:0] s139;
  wire [2:0] s140;
  wire s141;
  wire s142;
  wire s143;
  wire s144;
  wire s145;
  wire s146;
  wire s147;
  wire [7:0] s148;
  wire s149;
  wire s150;
  wire s151;
  wire s152;
  wire s153;
  wire s154;
  wire s155;
  wire s156;
  wire [2:0] s157;
  wire s158;
  wire [1:0] s159;
  wire s160;
  wire s161;
  wire [15:0] s162;
  wire s163;
  wire InterLock;
  wire s164;
  wire intr;
  wire s165;
  wire s166;
  wire s167;
  wire s168;
  wire interEnable;
  wire s169;
  wire [15:0] s170;
  wire s171;
  wire s172;
  wire [11:0] s173;
  wire s174;
  wire [11:0] s175;
  wire s176;
  wire [11:0] s177;
  wire s178;
  wire s179;
  wire [15:0] s180;
  wire [15:0] s181;
  wire s182;
  wire s183;
  wire s184;
  wire s185;
  wire s186;
  wire s187;
  wire s188;
  wire s189;
  wire s190;
  wire s191;
  wire s192;
  wire [31:0] s193;
  assign Din[0] = uio_in[0];
  assign Din[1] = uio_in[1];
  assign Din[2] = uio_in[2];
  assign Din[3] = uio_in[3];
  assign Din[4] = uio_in[4];
  assign Din[5] = uio_in[5];
  assign Din[6] = uio_in[6];
  assign Din[7] = uio_in[7];
  assign Din[8] = 1'b0;
  assign Din[9] = 1'b0;
  assign Din[10] = 1'b0;
  assign Din[11] = 1'b0;
  assign Din[12] = 1'b0;
  assign Din[13] = 1'b0;
  assign Din[14] = 1'b0;
  assign Din[15] = 1'b0;
  assign s127 = ~ clk;
  assign s135 = ~ rst_n;
  DIG_Counter_Nbit #(
    .Bits(2)
  )
  DIG_Counter_Nbit_i0 (
    .en( 1'b1 ),
    .C( clk ),
    .clr( s135 ),
    .out( s132 ),
    .ovf( s136 )
  );
  assign s133 = s132[0];
  assign s134 = s132[1];
  assign s128 = (s133 & ~ s134);
  assign s130 = (~ s133 & s134);
  assign C = (s133 & s134);
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i1 (
    .D( ui_in ),
    .C( s127 ),
    .en( s128 ),
    .Q( s129 )
  );
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i2 (
    .D( ui_in ),
    .C( s127 ),
    .en( s130 ),
    .Q( s131 )
  );
  assign s166 = ~ C;
  assign s168 = ~ C;
  assign s174 = ~ C;
  Mux_2x1 Mux_2x1_i3 (
    .sel( rst_n ),
    .in_0( clk ),
    .in_1( C ),
    .out( s30 )
  );
  assign s31 = ~ s30;
  assign s8[7:0] = s131;
  assign s8[15:8] = s129;
  singExtend singExtend_i4 (
    .inst( s8 ),
    .\4S ( s4 ),
    .\8SD ( s5 ),
    .\4D ( s6 )
  );
  assign s9 = s8[3:0];
  assign s10 = s8[7:4];
  assign OPcode = s8[15:8];
  assign s102 = OPcode[6:0];
  assign imm = OPcode[7];
  Mux_2x1_NBits #(
    .Bits(7)
  )
  Mux_2x1_NBits_i5 (
    .sel( imm ),
    .in_0( s102 ),
    .in_1( 7'b0 ),
    .out( s103 )
  );
  assign s110 = s103[0];
  assign s109 = s103[1];
  assign s108 = s103[2];
  assign s107 = s103[3];
  assign s106 = s103[4];
  assign s105 = s103[5];
  assign s104 = s103[6];
  controllogic controllogic_i6 (
    .A( s104 ),
    .B( s105 ),
    .C( s106 ),
    .D( s107 ),
    .E( s108 ),
    .F( s109 ),
    .G( s110 ),
    .muxb0( s111 ),
    .muxb1( s112 ),
    .muxb2( s113 ),
    .src2D( src2D ),
    .aluop0( s114 ),
    .aluop1( s115 ),
    .aluop2( s116 ),
    .aluop3( s117 ),
    .aluop4( s118 ),
    .WE( WE ),
    .sf( sf ),
    .alu2D( alu2D ),
    .iem0( s119 ),
    .iem1( s120 ),
    .br0( s121 ),
    .br1( s122 ),
    .br2( s123 ),
    .muxA( muxA ),
    .ld( ld ),
    .st( st ),
    .abs( abs ),
    .ioW( ioW ),
    .ioR( ioR ),
    .stPC( stPC ),
    .Reti( Reti ),
    .randomSel( RandomNUMSel ),
    .timerSel( timer_Sel )
  );
  assign s15[0] = (stPC | ld | RandomNUMSel);
  assign s15[1] = (ioR | stPC);
  assign s15[2] = (timer_Sel | RandomNUMSel);
  assign muxB[0] = s113;
  assign muxB[1] = s112;
  assign muxB[2] = s111;
  assign aluOp[0] = s118;
  assign aluOp[1] = s117;
  assign aluOp[2] = s116;
  assign aluOp[3] = s115;
  assign aluOp[4] = s114;
  assign br[0] = s123;
  assign br[1] = s122;
  assign br[2] = s121;
  assign iem[0] = s120;
  assign iem[1] = s119;
  ImReg ImReg_i7 (
    .en( imm ),
    .iem( iem ),
    .C( C ),
    .inst( s8 ),
    .imm( s3 )
  );
  assign s20 = br[1:0];
  assign sel = aluOp[3:0];
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i8 (
    .sel( muxA ),
    .in_0( s0 ),
    .in_1( s1 ),
    .out( s2 )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i9 (
    .sel( muxB ),
    .in_0( s1 ),
    .in_1( 16'b0 ),
    .in_2( s3 ),
    .in_3( 16'b0 ),
    .in_4( 16'b0 ),
    .in_5( s4 ),
    .in_6( s5 ),
    .in_7( s6 ),
    .out( s7 )
  );
  // mem
  DIG_RAMDualPort #(
    .Bits(16),
    .AddrBits(5)
  )
  DIG_RAMDualPort_i10 (
    .A( s11 ),
    .Din( s1 ),
    .str( s12 ),
    .C( C ),
    .ld( s13 ),
    .D( s14 )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i11 (
    .sel( s15 ),
    .in_0( s16 ),
    .in_1( s17 ),
    .in_2( Din ),
    .in_3( s18 ),
    .in_4( timer_in ),
    .in_5( RandomNUM ),
    .in_6( 16'b0 ),
    .in_7( 16'b0 ),
    .out( s19 )
  );
  Mux_4x1 Mux_4x1_i12 (
    .sel( s20 ),
    .in_0( 1'b0 ),
    .in_1( s21 ),
    .in_2( s22 ),
    .in_3( s23 ),
    .out( s24 )
  );
  assign s25 = (s24 ^ br[2]);
  // Carry
  DIG_Register DIG_Register_i13 (
    .D( s26 ),
    .C( C ),
    .en( sf ),
    .Q( s21 )
  );
  // Zero
  DIG_Register DIG_Register_i14 (
    .D( s27 ),
    .C( C ),
    .en( sf ),
    .Q( s22 )
  );
  // Neg
  DIG_Register DIG_Register_i15 (
    .D( s28 ),
    .C( C ),
    .en( sf ),
    .Q( s23 )
  );
  RegisterBlock RegisterBlock_i16 (
    .DataIn( s19 ),
    .WE( WE ),
    .clk( C ),
    .src( s9 ),
    .Dest( s10 ),
    .RDest( s0 ),
    .Rsrc( s1 )
  );
  // PC
  DIG_Register_BUS #(
    .Bits(12)
  )
  DIG_Register_BUS_i17 (
    .D( s29 ),
    .C( s31 ),
    .en( 1'b1 ),
    .Q( pcOut )
  );
  Mux_2x1_NBits #(
    .Bits(12)
  )
  Mux_2x1_NBits_i18 (
    .sel( abs ),
    .in_0( s34 ),
    .in_1( s35 ),
    .out( s36 )
  );
  assign s38 = (s37 & ioW);
  DIG_Register_BUS #(
    .Bits(4)
  )
  DIG_Register_BUS_i19 (
    .D( s39 ),
    .C( C ),
    .en( s38 ),
    .Q( outputToOutside )
  );
  Mux_16x1_NBits #(
    .Bits(16)
  )
  Mux_16x1_NBits_i20 (
    .sel( sel ),
    .in_0( s7 ),
    .in_1( s40 ),
    .in_2( s41 ),
    .in_3( s42 ),
    .in_4( s43 ),
    .in_5( s44 ),
    .in_6( s45 ),
    .in_7( s46 ),
    .in_8( s47 ),
    .in_9( s48 ),
    .in_10( s49 ),
    .in_11( s50 ),
    .in_12( s51 ),
    .in_13( s52 ),
    .in_14( 16'b0 ),
    .in_15( 16'b0 ),
    .out( s16 )
  );
  Mux_16x1 Mux_16x1_i21 (
    .sel( sel ),
    .in_0( 1'b0 ),
    .in_1( s53 ),
    .in_2( s54 ),
    .in_3( 1'b0 ),
    .in_4( 1'b0 ),
    .in_5( 1'b0 ),
    .in_6( 1'b0 ),
    .in_7( 1'b0 ),
    .in_8( s55 ),
    .in_9( s56 ),
    .in_10( s57 ),
    .in_11( 1'b0 ),
    .in_12( 1'b0 ),
    .in_13( 1'b0 ),
    .in_14( 1'b0 ),
    .in_15( 1'b0 ),
    .out( s26 )
  );
  assign s58 = (aluOp[4] & s21);
  // seed
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i22 (
    .D( s1 ),
    .C( C ),
    .en( s63 ),
    .Q( s64 )
  );
  assign s63 = (s66 & ioW);
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i23 (
    .J( s67 ),
    .C( C ),
    .K( s67 ),
    .Q( s61 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i24 (
    .Set( s69 ),
    .D( s70 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s71 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i25 (
    .Set( s72 ),
    .D( s71 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s73 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i26 (
    .Set( s74 ),
    .D( s73 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s75 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i27 (
    .Set( s76 ),
    .D( s75 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s77 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i28 (
    .Set( s78 ),
    .D( s77 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s79 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i29 (
    .Set( s80 ),
    .D( s79 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s81 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i30 (
    .Set( s82 ),
    .D( s81 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s83 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i31 (
    .Set( s84 ),
    .D( s83 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s85 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i32 (
    .Set( s86 ),
    .D( s85 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s87 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i33 (
    .Set( s88 ),
    .D( s87 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s89 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i34 (
    .Set( s90 ),
    .D( s89 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s91 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i35 (
    .Set( s92 ),
    .D( s91 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s93 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i36 (
    .Set( s94 ),
    .D( s93 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s95 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i37 (
    .Set( s96 ),
    .D( s95 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s97 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i38 (
    .Set( s98 ),
    .D( s97 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s99 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i39 (
    .Set( s100 ),
    .D( s99 ),
    .C( C ),
    .Clr( s68 ),
    .Q( s101 )
  );
  assign s60 = (C & s63);
  assign s125 = (s124 & ioW);
  DIG_Register_BUS #(
    .Bits(4)
  )
  DIG_Register_BUS_i40 (
    .D( s126 ),
    .C( C ),
    .en( s125 ),
    .Q( outputToOutsideEnable )
  );
  assign s138 = (s137 & ioW);
  // prescaler
  DIG_Register_BUS #(
    .Bits(3)
  )
  DIG_Register_BUS_i41 (
    .D( s139 ),
    .C( C ),
    .en( s138 ),
    .Q( s140 )
  );
  assign s142 = (s141 & ioW);
  // timer_is_active
  DIG_Register DIG_Register_i42 (
    .D( s143 ),
    .C( C ),
    .en( s142 ),
    .Q( s144 )
  );
  // Reset
  DIG_JK_FF #(
    .Default(0)
  )
  DIG_JK_FF_i43 (
    .J( s146 ),
    .C( C ),
    .K( 1'b1 ),
    .Q( s147 )
  );
  assign s146 = (s1[0] & (s145 & ioW));
  DIG_Counter_Nbit #(
    .Bits(8)
  )
  DIG_Counter_Nbit_i44 (
    .en( s144 ),
    .C( C ),
    .clr( 1'b0 ),
    .out( s148 )
  );
  // mem
  DIG_RAMDualPort #(
    .Bits(16),
    .AddrBits(2)
  )
  DIG_RAMDualPort_i45 (
    .A( s159 ),
    .Din( s1 ),
    .str( s160 ),
    .C( C ),
    .ld( s161 ),
    .D( s162 )
  );
  assign s160 = (s163 & st);
  assign s161 = (s163 & ld);
  assign intr = (~ InterLock & ~ imm & s164 & ~ 1'b0);
  // *
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i46 (
    .D( s165 ),
    .C( s166 ),
    .Q( InterLock )
  );
  assign s165 = ((InterLock & ~ Reti) | intr);
  // *
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i47 (
    .D( s167 ),
    .C( s168 ),
    .Q( s164 )
  );
  assign s167 = ((s164 & ~ Reti) | ((~ InterLock & (~ s184 & s182)) & interEnable));
  // intEn
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i48 (
    .D( s1 ),
    .C( C ),
    .en( s169 ),
    .Q( s170 )
  );
  assign s169 = (s171 & ioW);
  DIG_Register_BUS #(
    .Bits(12)
  )
  DIG_Register_BUS_i49 (
    .D( s36 ),
    .C( s174 ),
    .en( s172 ),
    .Q( s175 )
  );
  assign s176 = (interEnable & Reti);
  assign s179 = (s178 & ioW);
  // target
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i50 (
    .D( s1 ),
    .C( C ),
    .en( s179 ),
    .Q( s180 )
  );
  // Reload
  DIG_Register DIG_Register_i51 (
    .D( s185 ),
    .C( C ),
    .en( s186 ),
    .Q( s187 )
  );
  assign s186 = (s188 & ioW);
  assign s13 = (ld & ~ s163);
  assign s12 = (st & ~ s163);
  Mux_2x1_NBits #(
    .Bits(12)
  )
  Mux_2x1_NBits_i52 (
    .sel( rst_n ),
    .in_0( 12'b0 ),
    .in_1( s177 ),
    .out( s29 )
  );
  assign FlagOut[0] = s21;
  assign FlagOut[1] = s22;
  assign FlagOut[2] = s23;
  assign FlagOut[15:3] = 13'b0;
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i53 (
    .a( s16 ),
    .b( 16'b111 ),
    .\= ( s37 )
  );
  assign s42 = (s2 & s7);
  assign s43 = (s2 | s7);
  assign s44 = (s2 ^ s7);
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i54 (
    .a( s16 ),
    .b( 16'b0 ),
    .\= ( s27 )
  );
  assign s45 = ~ s2;
  DIG_Neg #(
    .Bits(16)
  )
  DIG_Neg_i55 (
    .in( s2 ),
    .out( s46 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i56 (
    .sel( s63 ),
    .in_0( 16'b0 ),
    .in_1( s64 ),
    .out( s65 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i57 (
    .a( s16 ),
    .b( 16'b1001 ),
    .\= ( s66 )
  );
  assign s70 = (s81 ^ (s91 ^ (s95 ^ s99)));
  assign RandomNUM[0] = s71;
  assign RandomNUM[1] = s73;
  assign RandomNUM[2] = s75;
  assign RandomNUM[3] = s77;
  assign RandomNUM[4] = s79;
  assign RandomNUM[5] = s81;
  assign RandomNUM[6] = s83;
  assign RandomNUM[7] = s85;
  assign RandomNUM[8] = s87;
  assign RandomNUM[9] = s89;
  assign RandomNUM[10] = s91;
  assign RandomNUM[11] = s93;
  assign RandomNUM[12] = s95;
  assign RandomNUM[13] = s97;
  assign RandomNUM[14] = s99;
  assign RandomNUM[15] = s101;
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i58 (
    .a( s16 ),
    .b( 16'b1000 ),
    .\= ( s124 )
  );
  assign uio_out[3:0] = pcOut[11:8];
  assign uio_out[7:4] = outputToOutside;
  assign uio_oe[3:0] = 4'b1111;
  assign uio_oe[7:4] = outputToOutsideEnable;
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i59 (
    .a( s2 ),
    .b( s7 ),
    .c_i( s58 ),
    .s( s40 ),
    .c_o( s53 )
  );
  DIG_Sub #(
    .Bits(16)
  )
  DIG_Sub_i60 (
    .a( s2 ),
    .b( s7 ),
    .c_i( s58 ),
    .s( s41 ),
    .c_o( s54 )
  );
  DIG_Add #(
    .Bits(12)
  )
  DIG_Add_i61 (
    .a( pcOut ),
    .b( 12'b1 ),
    .c_i( 1'b0 ),
    .s( s32 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i62 (
    .a( s16 ),
    .b( 16'b10 ),
    .\= ( s137 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i63 (
    .a( s16 ),
    .b( 16'b1 ),
    .\= ( s141 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i64 (
    .a( s16 ),
    .b( 16'b101 ),
    .\= ( s145 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i65 (
    .a( s16 ),
    .b( 16'b110 ),
    .\= ( s171 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i66 (
    .a( s16 ),
    .b( 16'b11 ),
    .\= ( s178 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i67 (
    .a( s180 ),
    .b( 16'b0 ),
    .\> ( s183 ),
    .\= ( s184 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i68 (
    .a( s16 ),
    .b( 16'b100 ),
    .\= ( s188 )
  );
  assign s51[3:0] = s2[7:4];
  assign s51[7:4] = s2[3:0];
  assign s51[11:8] = s2[15:12];
  assign s51[15:12] = s2[11:8];
  assign s50[7:0] = s2[15:8];
  assign s50[15:8] = s2[7:0];
  assign s48[14:0] = s2[15:1];
  assign s48[15] = s58;
  assign s47[0] = s58;
  assign s47[15:1] = s2[14:0];
  DIG_Mul_unsigned #(
    .Bits(16)
  )
  DIG_Mul_unsigned_i69 (
    .a( s2 ),
    .b( s7 ),
    .mul( s193 )
  );
  assign s11 = s16[4:0];
  assign s39 = s1[3:0];
  assign s28 = s16[15];
  assign s35 = s16[11:0];
  assign s126 = s1[3:0];
  assign uo_out = pcOut[7:0];
  assign s139 = s1[2:0];
  assign s143 = s1[0];
  assign s149 = s148[0];
  assign s150 = s148[1];
  assign s151 = s148[2];
  assign s152 = s148[3];
  assign s153 = s148[4];
  assign s154 = s148[5];
  assign s155 = s148[6];
  assign s156 = s148[7];
  assign s159 = s16[1:0];
  assign s163 = s16[5];
  assign interEnable = s170[0];
  assign s185 = s1[0];
  assign s57 = s2[0];
  assign s192 = s2[15];
  assign s56 = s2[0];
  assign s55 = s2[15];
  assign s18[11:0] = s32;
  assign s18[15:12] = 4'b0;
  DIG_Add #(
    .Bits(12)
  )
  DIG_Add_i70 (
    .a( s32 ),
    .b( s35 ),
    .c_i( 1'b0 ),
    .s( s33 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i71 (
    .sel( s163 ),
    .in_0( s14 ),
    .in_1( s162 ),
    .out( s17 )
  );
  assign s172 = (intr & interEnable);
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i72 (
    .sel( s183 ),
    .in_0( 16'b0 ),
    .in_1( s180 ),
    .out( s181 )
  );
  assign s49[13:0] = s2[14:1];
  assign s49[14] = s192;
  assign s49[15] = s192;
  assign s69 = s65[0];
  assign s72 = s65[1];
  assign s74 = s65[2];
  assign s76 = s65[3];
  assign s78 = s65[4];
  assign s80 = s65[5];
  assign s82 = s65[6];
  assign s84 = s65[7];
  assign s86 = s65[8];
  assign s88 = s65[9];
  assign s90 = s65[10];
  assign s92 = s65[11];
  assign s94 = s65[12];
  assign s96 = s65[13];
  assign s98 = s65[14];
  assign s100 = s65[15];
  assign s52 = s193[15:0];
  Mux_2x1_NBits #(
    .Bits(12)
  )
  Mux_2x1_NBits_i73 (
    .sel( s25 ),
    .in_0( s32 ),
    .in_1( s33 ),
    .out( s34 )
  );
  Mux_2x1_NBits #(
    .Bits(12)
  )
  Mux_2x1_NBits_i74 (
    .sel( s172 ),
    .in_0( s36 ),
    .in_1( 12'b10 ),
    .out( s173 )
  );
  Mux_2x1_NBits #(
    .Bits(12)
  )
  Mux_2x1_NBits_i75 (
    .sel( s176 ),
    .in_0( s173 ),
    .in_1( s175 ),
    .out( s177 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i76 (
    .Set( 1'b0 ),
    .D( s59 ),
    .C( s60 ),
    .Clr( s61 ),
    .Q( s62 ),
    .\~Q ( s59 )
  );
  assign s67 = (s62 | s61);
  assign s68 = (s63 & ~ s67);
  Mux_8x1 Mux_8x1_i77 (
    .sel( s157 ),
    .in_0( s149 ),
    .in_1( s150 ),
    .in_2( s151 ),
    .in_3( s152 ),
    .in_4( s153 ),
    .in_5( s154 ),
    .in_6( s155 ),
    .in_7( s156 ),
    .out( s158 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i78 (
    .a( s181 ),
    .b( timer_in ),
    .\= ( s182 )
  );
  assign s189 = (~ s184 & ((s182 & s187) | s147));
  DIG_CounterPreset #(
    .Bits(16),
    .maxValue(0)
  )
  DIG_CounterPreset_i79 (
    .en( s144 ),
    .C( s190 ),
    .dir( 1'b0 ),
    .in( 16'b0 ),
    .ld( s189 ),
    .clr( 1'b0 ),
    .out( timer_in )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i80 (
    .sel( s189 ),
    .in_0( s140 ),
    .in_1( 3'b0 ),
    .out( s157 )
  );
  assign s191 = (InterLock | ((s182 & ~ s184) & ~ s189));
  Mux_2x1 Mux_2x1_i81 (
    .sel( s191 ),
    .in_0( s158 ),
    .in_1( 1'b1 ),
    .out( s190 )
  );
endmodule
